<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glass Box Simulator - Graph Algorithms</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .main-header {
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
            border-bottom: 3px solid #1e88e5;
            padding: 25px 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .main-header h1 {
            font-size: 36px;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .main-header h1 span {
            color: #1e88e5;
        }

        .container {
            display: flex;
            height: calc(100vh - 100px);
        }

        .sidebar {
            width: 200px;
            background: #2c2c2c;
            border-right: 2px solid #1e88e5;
            padding: 20px 0;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
        }

        .sidebar h3 {
            color: #1e88e5;
            padding: 0 20px 15px 20px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            margin-bottom: 10px;
        }

        .algorithm-btn {
            width: 100%;
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: #b0b0b0;
            text-align: left;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s;
            border-left: 3px solid transparent;
        }

        .algorithm-btn:hover {
            background: #3a3a3a;
            color: #ffffff;
            border-left: 3px solid #1e88e5;
        }

        .algorithm-btn.active {
            background: #1e88e5;
            color: #ffffff;
            border-left: 3px solid #ffffff;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .nav-tabs {
            background: #2c2c2c;
            border-bottom: 2px solid #444;
            display: flex;
            padding: 0;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            background: transparent;
            border: none;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            background: #3a3a3a;
            color: #ffffff;
        }

        .nav-tab.active {
            background: #1a1a1a;
            color: #1e88e5;
            border-bottom: 3px solid #1e88e5;
        }

        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #1a1a1a;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.4s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h2 {
            color: #1e88e5;
            margin-bottom: 20px;
            font-size: 28px;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        h3 {
            color: #ffffff;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 20px;
        }

        p {
            line-height: 1.8;
            color: #c0c0c0;
            margin-bottom: 15px;
        }

        ul {
            margin-left: 30px;
            line-height: 2;
            color: #c0c0c0;
        }

        ul li {
            margin-bottom: 8px;
        }

        .algorithm-box {
            background: #2c2c2c;
            border-left: 4px solid #1e88e5;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            font-size: 13px;
            color: #00ff00;
            border-radius: 4px;
            line-height: 1.6;
        }

        .highlight {
            background: #1e88e5;
            padding: 2px 6px;
            border-radius: 3px;
            color: #ffffff;
            font-weight: 600;
        }

        .simulation-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: calc(100vh - 250px);
        }

        .canvas-section {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
        }

        .canvas-section h3 {
            color: #1e88e5;
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        canvas {
            width: 100%;
            flex: 1;
            background: #1a1a1a;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .controls-section {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            margin-bottom: 5px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #1e88e5;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: #1e88e5;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover:not(:disabled) {
            background: #1976d2;
            box-shadow: 0 4px 12px rgba(30, 136, 229, 0.4);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            color: #888;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #444;
            border-radius: 4px;
            font-size: 13px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .info-box {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .info-box h4 {
            color: #1e88e5;
            margin-bottom: 10px;
            font-size: 13px;
            text-transform: uppercase;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #c0c0c0;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #555;
            flex-shrink: 0;
        }

        .display-box {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 4px;
            min-height: 60px;
            max-height: 150px;
            border: 1px solid #444;
            overflow: hidden;
        }

        .display-box h4 {
            color: #1e88e5;
            margin-bottom: 10px;
            font-size: 13px;
            text-transform: uppercase;
        }

        .items-container {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: flex-start;
            max-width: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            max-height: 100px;
            padding: 2px;
        }

        .items-container::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .items-container::-webkit-scrollbar-track {
            background: #2c2c2c;
            border-radius: 3px;
        }

        .items-container::-webkit-scrollbar-thumb {
            background: #1e88e5;
            border-radius: 3px;
        }

        .item-badge {
            background: #1e88e5;
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 15px;
            font-weight: 600;
            font-size: 11px;
            white-space: nowrap;
            display: inline-block;
            flex-shrink: 0;
        }

        .step-info {
            background: #2c2c2c;
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            border-left: 4px solid #1e88e5;
            line-height: 1.4;
            color: #c0c0c0;
            word-wrap: break-word;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid #444;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #1e88e5;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #1e88e5;
            border-radius: 5px;
        }

        .procedure-step {
            background: #2c2c2c;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #1e88e5;
            border-radius: 4px;
        }

        .procedure-step h4 {
            color: #1e88e5;
            margin-bottom: 10px;
        }

        /* MCQ Styles */
        .mcq-container {
            max-width: 900px;
        }

        .mcq-question {
            background: #2c2c2c;
            padding: 20px;
            margin-bottom: 25px;
            border-radius: 8px;
            border: 2px solid #444;
            transition: all 0.3s;
        }

        .mcq-question h4 {
            color: #1e88e5;
            margin-bottom: 15px;
            font-size: 16px;
            line-height: 1.6;
        }

        .mcq-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .mcq-option {
            background: #1a1a1a;
            padding: 14px 18px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #444;
            color: #c0c0c0;
            font-size: 14px;
            line-height: 1.5;
        }

        .mcq-option:hover {
            background: #3a3a3a;
            border-color: #1e88e5;
            transform: translateX(5px);
        }

        .mcq-option.selected {
            background: #1e88e5;
            color: #ffffff;
            border-color: #1e88e5;
            font-weight: 600;
        }

        .mcq-option.correct {
            background: #4caf50;
            border-color: #4caf50;
            color: #ffffff;
            font-weight: 600;
        }

        .mcq-option.incorrect {
            background: #f44336;
            border-color: #f44336;
            color: #ffffff;
            font-weight: 600;
        }

        .mcq-option strong {
            margin-right: 8px;
            color: inherit;
        }

        .submit-mcq {
            margin-top: 30px;
            background: #1e88e5;
            padding: 15px 40px;
            font-size: 16px;
            max-width: 400px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .submit-mcq:hover {
            background: #1976d2;
        }

        #mcqResult {
            margin-top: 30px;
        }

        .mcq-explanation {
            margin-top: 12px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 200px;
            }
        }

        /* AI Tutor Panel Styles */
        .ai-tutor-section {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #1e88e5;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ai-tutor-section h3 {
            color: #1e88e5;
            margin: 0 0 10px 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .ai-toggle label {
            color: #c0c0c0;
            font-size: 13px;
            flex: 1;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #555;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #1e88e5;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        .ai-explanation-box {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #1e88e5;
            min-height: 100px;
            max-height: 400px;
            overflow-y: auto;
        }

        .ai-explanation-box h4 {
            color: #1e88e5;
            margin: 0 0 10px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-explanation-box h4::before {
            content: 'ü§ñ';
            font-size: 18px;
        }

        .ai-explanation-text {
            color: #c0c0c0;
            line-height: 1.8;
            font-size: 13px;
        }

        .ai-explanation-text p {
            margin: 0 0 12px 0;
        }

        .ai-explanation-text strong {
            color: #1e88e5;
        }

        .ai-explanation-text ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .ai-explanation-text li {
            margin: 5px 0;
        }

        .ai-loading {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #1e88e5;
            font-size: 13px;
            padding: 10px;
        }

        .ai-loading::before {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid #1e88e5;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .ai-insight {
            background: rgba(30, 136, 229, 0.1);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #1e88e5;
        }

        .ai-insight-label {
            color: #1e88e5;
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 5px;
        }

        /* Applications Section Styles */
        .applications-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .application-card {
            background: #2c2c2c;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .application-card:hover {
            border-color: #1e88e5;
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(30, 136, 229, 0.3);
        }

        .application-card.active {
            border-color: #1e88e5;
            background: #1a1a1a;
        }

        .app-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 15px;
        }

        .app-title {
            color: #1e88e5;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            text-align: center;
        }

        .app-description {
            color: #c0c0c0;
            font-size: 13px;
            line-height: 1.6;
            text-align: center;
            margin-bottom: 15px;
        }

        .app-try-btn {
            width: 100%;
            padding: 10px;
            background: #1e88e5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .app-try-btn:hover {
            background: #1976d2;
        }

        .interactive-demo {
            background: #2c2c2c;
            border: 2px solid #1e88e5;
            border-radius: 8px;
            padding: 25px;
            margin-top: 25px;
            display: none;
        }

        .interactive-demo.active {
            display: block;
            animation: slideIn 0.4s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .demo-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #444;
        }

        .demo-title {
            color: #1e88e5;
            font-size: 24px;
            font-weight: 600;
        }

        .demo-close {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .demo-content {
            margin-top: 20px;
        }

        .demo-scenario {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #1e88e5;
        }

        .demo-scenario h4 {
            color: #1e88e5;
            margin-bottom: 10px;
        }

        .demo-input-group {
            margin: 15px 0;
        }

        .demo-input-group label {
            display: block;
            color: #1e88e5;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .demo-input-group input,
        .demo-input-group select {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .demo-result {
            background: rgba(30, 136, 229, 0.1);
            border: 2px solid #1e88e5;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
        }

        .demo-result h4 {
            color: #1e88e5;
            margin-bottom: 15px;
        }

        .demo-visual {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .demo-step {
            background: #2c2c2c;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 4px;
            border-left: 3px solid #1e88e5;
            color: #c0c0c0;
            font-size: 13px;
        }

        .demo-highlight {
            background: #1e88e5;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="main-header">
        <h1><span>GLASS BOX</span> SIMULATOR</h1>
    </div>

    <div class="container">
        <div class="sidebar">
            <h3>Algorithms</h3>
            <button class="algorithm-btn active" onclick="selectAlgorithm('bfs', event)">BFS</button>
            <button class="algorithm-btn" onclick="selectAlgorithm('dfs', event)">DFS</button>
            <button class="algorithm-btn" onclick="selectAlgorithm('dijkstra', event)">DIJKSTRA</button>
            <button class="algorithm-btn" onclick="selectAlgorithm('astar', event)">A* STAR</button>
            <button class="algorithm-btn" onclick="selectAlgorithm('prim', event)">PRIM'S</button>
            <button class="algorithm-btn" onclick="selectAlgorithm('kruskal', event)">KRUSKAL'S</button>
        </div>

        <div class="main-content">
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="showTab('about', event)">About</button>
                <button class="nav-tab" onclick="showTab('theory', event)">Theory</button>
                <button class="nav-tab" onclick="showTab('procedure', event)">Procedure</button>
                <button class="nav-tab" onclick="showTab('simulation', event)">Simulation</button>
                <button class="nav-tab" onclick="showTab('applications', event)">Applications</button>
                <button class="nav-tab" onclick="showTab('mcq', event)">MCQ</button>
            </div>

            <div class="content-area" id="contentArea"></div>
        </div>
    </div>

    <script>
        let currentAlgorithm = 'bfs';
        let currentTab = 'about';
        
        let canvas, ctx;
        let vertices = [];
        let edges = [];
        let source = null;
        let goal = null;  // For A* algorithm
        let queue = [];
        let explored = 0;
        let step = 0;
        let history = [];
        let historyIndex = -1;
        let initialized = false;
        let traversal = [];
        let adjList = {};
        
        // AI Tutor variables
        let aiEnabled = true;
        let aiExplaining = false;

        const algorithmContent = {
            bfs: {
                about: `
                    <h2>About BFS (Breadth-First Search)</h2>
                    
                    <p>Breadth-First Search (BFS) is one of the most fundamental graph traversal algorithms. It explores vertices in order of their distance from the source vertex, discovering all vertices at distance k before discovering any vertices at distance k+1.</p>
                    
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Data Structure:</strong> Uses a FIFO (First-In-First-Out) Queue</li>
                        <li><strong>Exploration Strategy:</strong> Level-by-level traversal</li>
                        <li><strong>Time Complexity:</strong> <span class="highlight">O(V + E)</span> where V = vertices, E = edges</li>
                        <li><strong>Space Complexity:</strong> <span class="highlight">O(V)</span></li>
                        <li><strong>Completeness:</strong> Always finds a solution if one exists</li>
                        <li><strong>Optimality:</strong> Finds shortest path in unweighted graphs</li>
                    </ul>
                    
                    <h3>Applications</h3>
                    <ul>
                        <li><strong>Shortest Path Finding:</strong> Finding shortest path in unweighted graphs</li>
                        <li><strong>Web Crawling:</strong> Search engines use BFS to crawl web pages</li>
                        <li><strong>Social Networks:</strong> Finding people within 'n' connections (LinkedIn, Facebook)</li>
                        <li><strong>Broadcasting:</strong> Broadcasting in networks</li>
                        <li><strong>GPS Navigation:</strong> Finding nearest locations</li>
                        <li><strong>Peer-to-Peer Networks:</strong> Finding neighboring nodes</li>
                        <li><strong>Garbage Collection:</strong> Cheney's algorithm uses BFS</li>
                    </ul>
                    
                    <h3>Advantages</h3>
                    <ul>
                        <li>Guarantees shortest path in unweighted graphs</li>
                        <li>Simple to implement and understand</li>
                        <li>Complete - will find solution if exists</li>
                        <li>Can be used to test graph properties (bipartiteness, connectivity)</li>
                    </ul>
                    
                    <h3>Disadvantages</h3>
                    <ul>
                        <li>Requires more memory than DFS due to queue storage</li>
                        <li>Not suitable for decision trees or game playing</li>
                        <li>May explore irrelevant vertices in large graphs</li>
                    </ul>
                `,
                theory: `
                    <h2>BFS Theory</h2>
                    
                    <h3>Algorithm Description</h3>
                    <p>BFS systematically explores the edges of a graph to discover every vertex reachable from a source vertex. It computes the distance (smallest number of edges) from the source to each reachable vertex.</p>
                    
                    <h3>Color Coding Scheme</h3>
                    <p>BFS uses three colors to track vertex states:</p>
                    <ul>
                        <li><span class="highlight">WHITE</span>: Undiscovered vertices (not yet visited)</li>
                        <li><span class="highlight">GRAY</span>: Discovered but not fully explored (in queue)</li>
                        <li><span class="highlight">BLACK</span>: Fully explored (all neighbors discovered)</li>
                    </ul>
                    
                    <h3>Data Structures</h3>
                    <ul>
                        <li><strong>color[u]:</strong> Color of vertex u</li>
                        <li><strong>d[u]:</strong> Distance from source to vertex u</li>
                        <li><strong>œÄ[u]:</strong> Predecessor of u in BFS tree</li>
                        <li><strong>Queue Q:</strong> FIFO queue managing gray vertices</li>
                    </ul>
                    
                    <h3>BFS Pseudocode</h3>
                    <div class="algorithm-box">
BFS(G, s)
1  for each vertex u ‚àà V[G] ‚àí {s}
2      color[u] ‚Üê WHITE
3      d[u] ‚Üê ‚àû
4      œÄ[u] ‚Üê NIL
5  color[s] ‚Üê GRAY
6  d[s] ‚Üê 0
7  œÄ[s] ‚Üê NIL
8  Q ‚Üê ‚àÖ
9  ENQUEUE(Q, s)
10 while Q ‚â† ‚àÖ
11     u ‚Üê DEQUEUE(Q)
12     for each v ‚àà Adj[u]
13         if color[v] = WHITE
14             color[v] ‚Üê GRAY
15             d[v] ‚Üê d[u] + 1
16             œÄ[v] ‚Üê u
17             ENQUEUE(Q, v)
18     color[u] ‚Üê BLACK
                    </div>
                    
                    <h3>How BFS Works</h3>
                    <ul>
                        <li><strong>Initialization (Lines 1-9):</strong> All vertices except source are colored WHITE with distance ‚àû. Source is colored GRAY with distance 0 and enqueued.</li>
                        <li><strong>Main Loop (Lines 10-18):</strong> Dequeue vertex u, explore all WHITE neighbors, color them GRAY, update distances, enqueue them, then color u BLACK.</li>
                        <li><strong>Termination:</strong> Algorithm terminates when queue is empty (all reachable vertices explored).</li>
                    </ul>
                    
                    <h3>Properties of BFS</h3>
                    <ul>
                        <li>BFS discovers all vertices at distance k before discovering vertices at distance k+1</li>
                        <li>The breadth-first tree contains all reachable vertices from source</li>
                        <li>Path in BFS tree from source to any vertex is a shortest path</li>
                        <li>For any edge (u,v), |d[u] - d[v]| ‚â§ 1</li>
                    </ul>
                    
                    <h3>Time Complexity Analysis</h3>
                    <p>After initialization, each vertex is enqueued at most once, and dequeued at most once. Since each adjacency list is scanned when its vertex is dequeued, and the sum of all adjacency list lengths is Œò(E), the total running time is <span class="highlight">O(V + E)</span>.</p>
                `,
                procedure: `
                    <h2>Procedure to Perform BFS Simulation</h2>
                    
                    <div class="procedure-step">
                        <h4>Step 1: Understanding the Graph</h4>
                        <p>The simulation displays an undirected graph with vertices labeled A through F. Each vertex can be in one of three states: WHITE (undiscovered), GRAY (discovered but not explored), or BLACK (fully explored).</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 2: Select Source Vertex</h4>
                        <p>Click on the "Select Source" dropdown menu in the controls panel and choose any vertex (A, B, C, D, E, or F) as your starting point. This vertex will be marked as the source for the BFS traversal.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 3: Initialize BFS</h4>
                        <p>Click the "Next Step" button once. This will:</p>
                        <ul>
                            <li>Color the source vertex GRAY</li>
                            <li>Set its distance to 0</li>
                            <li>Add it to the queue</li>
                            <li>Initialize all other vertices as WHITE with distance ‚àû</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 4: Execute BFS Step by Step</h4>
                        <p>Continue clicking "Next Step" to advance through the algorithm:</p>
                        <ul>
                            <li><strong>Dequeue:</strong> The algorithm removes a vertex from the front of the queue</li>
                            <li><strong>Explore:</strong> It examines all neighbors of the dequeued vertex</li>
                            <li><strong>Discover:</strong> WHITE neighbors are colored GRAY and added to queue</li>
                            <li><strong>Complete:</strong> The dequeued vertex is colored BLACK</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 5: Observe Key Information</h4>
                        <p>While stepping through the algorithm, monitor:</p>
                        <ul>
                            <li><strong>Queue Display:</strong> Shows which vertices are waiting to be explored</li>
                            <li><strong>Traversal Order:</strong> Shows the sequence in which vertices are discovered</li>
                            <li><strong>Distance Labels:</strong> Each vertex shows its distance from the source (d=n)</li>
                            <li><strong>Statistics:</strong> Track number of explored vertices and current step</li>
                            <li><strong>Step Info:</strong> Provides detailed information about current operation</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 6: Understanding the Output</h4>
                        <p>When BFS completes:</p>
                        <ul>
                            <li>All reachable vertices will be colored BLACK</li>
                            <li>Queue will be empty</li>
                            <li>Each vertex displays its shortest distance from source</li>
                            <li>Traversal order shows the level-by-level exploration sequence</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 7: Reset and Experiment</h4>
                        <p>Click "Reset" to clear the simulation and try with:</p>
                        <ul>
                            <li>Different source vertices</li>
                            <li>Observe how distances change</li>
                            <li>Compare traversal orders</li>
                            <li>Verify shortest path properties</li>
                        </ul>
                    </div>
                    
                    <h3>Tips for Learning</h3>
                    <ul>
                        <li>Try BFS from each vertex to understand different perspectives</li>
                        <li>Verify that BFS explores level by level (all distance k before k+1)</li>
                        <li>Notice how the queue maintains the frontier of discovered vertices</li>
                        <li>Compare the distance values to verify shortest paths</li>
                    </ul>
                `
            },
            dfs: {
                about: `
                    <h2>About DFS (Depth-First Search)</h2>
                    
                    <p>Depth-First Search (DFS) is a fundamental graph traversal algorithm that explores as far as possible along each branch before backtracking. It searches "deeper" in the graph whenever possible.</p>
                    
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Data Structure:</strong> Uses a Stack (or recursion)</li>
                        <li><strong>Exploration Strategy:</strong> Depth-first (go deep then backtrack)</li>
                        <li><strong>Time Complexity:</strong> <span class="highlight">O(V + E)</span></li>
                        <li><strong>Space Complexity:</strong> <span class="highlight">O(V)</span> for recursion stack</li>
                        <li><strong>Completeness:</strong> Complete in finite spaces</li>
                        <li><strong>Timestamps:</strong> Records discovery and finishing times</li>
                    </ul>
                    
                    <h3>Applications</h3>
                    <ul>
                        <li><strong>Topological Sorting:</strong> Ordering tasks with dependencies</li>
                        <li><strong>Cycle Detection:</strong> Finding cycles in directed/undirected graphs</li>
                        <li><strong>Path Finding:</strong> Finding paths between vertices</li>
                        <li><strong>Strongly Connected Components:</strong> Kosaraju's and Tarjan's algorithms</li>
                        <li><strong>Maze Solving:</strong> Finding way through mazes</li>
                        <li><strong>Puzzle Solving:</strong> Chess, Sudoku solvers</li>
                        <li><strong>Web Crawling:</strong> Deep crawling of websites</li>
                    </ul>
                    
                    <h3>Advantages</h3>
                    <ul>
                        <li>Memory efficient - requires less memory than BFS</li>
                        <li>Useful for decision trees and game playing</li>
                        <li>Natural recursive implementation</li>
                        <li>Discovers back edges (useful for cycle detection)</li>
                        <li>Can be terminated when goal is found</li>
                    </ul>
                    
                    <h3>Disadvantages</h3>
                    <ul>
                        <li>May get stuck in infinite loops without cycle detection</li>
                        <li>Not guaranteed to find shortest path</li>
                        <li>May go very deep before finding solution</li>
                        <li>Stack overflow risk in deep recursion</li>
                    </ul>
                `,
                theory: `
                    <h2>DFS Theory</h2>
                    
                    <h3>Algorithm Description</h3>
                    <p>DFS explores edges out of the most recently discovered vertex that still has unexplored edges. When all edges from a vertex have been explored, the search backtracks to explore edges leaving the vertex from which it was discovered.</p>
                    
                    <h3>Color Coding Scheme</h3>
                    <ul>
                        <li><span class="highlight">WHITE</span>: Undiscovered vertex</li>
                        <li><span class="highlight">GRAY</span>: Discovered but not finished (currently exploring)</li>
                        <li><span class="highlight">BLACK</span>: Finished (all descendants discovered)</li>
                    </ul>
                    
                    <h3>Timestamps</h3>
                    <p>DFS maintains two timestamps for each vertex:</p>
                    <ul>
                        <li><strong>d[v]:</strong> Discovery time - when vertex v is first discovered (grayed)</li>
                        <li><strong>f[v]:</strong> Finishing time - when search finishes examining v's adjacency list (blackened)</li>
                        <li><strong>Property:</strong> For every vertex u, d[u] < f[u]</li>
                        <li><strong>Interval:</strong> Vertex is WHITE before d[u], GRAY between d[u] and f[u], BLACK after f[u]</li>
                    </ul>
                    
                    <h3>DFS Pseudocode</h3>
                    <div class="algorithm-box">
DFS(G)
1  for each vertex u ‚àà V[G]
2      color[u] ‚Üê WHITE
3      œÄ[u] ‚Üê NIL
4  time ‚Üê 0
5  for each vertex u ‚àà V[G]
6      if color[u] = WHITE
7          DFS-VISIT(u)

DFS-VISIT(u)
1  color[u] ‚Üê GRAY
2  time ‚Üê time + 1
3  d[u] ‚Üê time
4  for each v ‚àà Adj[u]
5      if color[v] = WHITE
6          œÄ[v] ‚Üê u
7          DFS-VISIT(v)
8  color[u] ‚Üê BLACK
9  f[u] ‚Üê time ‚Üê time + 1
                    </div>
                    
                    <h3>How DFS Works</h3>
                    <ul>
                        <li><strong>Initialization:</strong> All vertices are colored WHITE</li>
                        <li><strong>Visit:</strong> When visiting vertex u, color it GRAY and record discovery time</li>
                        <li><strong>Explore:</strong> Recursively visit all WHITE neighbors</li>
                        <li><strong>Finish:</strong> After exploring all neighbors, color u BLACK and record finishing time</li>
                        <li><strong>Repeat:</strong> Continue with next WHITE vertex until all are BLACK</li>
                    </ul>
                    
                    <h3>Properties of DFS</h3>
                    <ul>
                        <li><strong>Parenthesis Structure:</strong> Discovery and finishing times have proper nesting</li>
                        <li><strong>Edge Classification:</strong> Tree edges, back edges, forward edges, cross edges</li>
                        <li><strong>Depth-First Forest:</strong> May produce multiple trees</li>
                        <li><strong>White Path Theorem:</strong> v is descendant of u iff at time d[u], there's a path from u to v consisting of WHITE vertices</li>
                    </ul>
                    
                    <h3>Time Complexity Analysis</h3>
                    <p>Each vertex is visited exactly once, and each edge is examined exactly twice (once from each endpoint). Therefore, the time complexity is <span class="highlight">O(V + E)</span>.</p>
                `,
                procedure: `
                    <h2>Procedure to Perform DFS Simulation</h2>
                    
                    <div class="procedure-step">
                        <h4>Step 1: Understand the Graph</h4>
                        <p>The simulation displays a graph where DFS will explore as deeply as possible along each branch before backtracking. Timestamps will be shown as "d/f" format.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 2: Select Source Vertex</h4>
                        <p>Choose a starting vertex from the dropdown menu. This will be the root of the first depth-first tree.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 3: Initialize DFS</h4>
                        <p>Click "Next Step" to initialize. The algorithm will:</p>
                        <ul>
                            <li>Set global time to 0</li>
                            <li>Color all vertices WHITE</li>
                            <li>Prepare to visit the source vertex</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 4: Observe Discovery Phase</h4>
                        <p>When a vertex is discovered:</p>
                        <ul>
                            <li>It turns GRAY</li>
                            <li>Time increments and is recorded as discovery time d[v]</li>
                            <li>The vertex is added to the call stack</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 5: Watch Exploration</h4>
                        <p>The algorithm explores each WHITE neighbor recursively:</p>
                        <ul>
                            <li>Selects a WHITE neighbor</li>
                            <li>Recursively visits it (goes deeper)</li>
                            <li>Backtracks when no WHITE neighbors remain</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 6: Observe Finishing Phase</h4>
                        <p>When a vertex is finished:</p>
                        <ul>
                            <li>All its neighbors have been explored</li>
                            <li>It turns BLACK</li>
                            <li>Time increments and is recorded as finishing time f[v]</li>
                            <li>It's removed from call stack (backtrack)</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 7: Monitor Key Displays</h4>
                        <ul>
                            <li><strong>Call Stack:</strong> Shows current recursive call chain</li>
                            <li><strong>Timestamps:</strong> Displayed as "d/f" on each vertex</li>
                            <li><strong>Traversal Order:</strong> Shows discovery sequence</li>
                            <li><strong>Time Counter:</strong> Global time value</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 8: Analyze Results</h4>
                        <p>When DFS completes:</p>
                        <ul>
                            <li>All vertices are BLACK</li>
                            <li>Each vertex shows both timestamps</li>
                            <li>Verify parenthesis structure: d[u] < d[v] < f[v] < f[u] for tree edges</li>
                        </ul>
                    </div>
                    
                    <h3>Understanding Timestamps</h3>
                    <ul>
                        <li>If d[u] < d[v] < f[v] < f[u]: v is descendant of u</li>
                        <li>If d[u] < f[u] < d[v] < f[v]: u and v are in separate subtrees</li>
                        <li>Discovery and finishing times form a parenthesis structure</li>
                    </ul>
                `
            },
            dijkstra: {
                about: `
                    <h2>About Dijkstra's Algorithm</h2>
                    
                    <p>Dijkstra's algorithm is a greedy algorithm that solves the single-source shortest-paths problem on weighted, directed graphs where all edge weights are non-negative. Discovered by Edsger W. Dijkstra in 1956.</p>
                    
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Strategy:</strong> Greedy approach</li>
                        <li><strong>Data Structure:</strong> Priority Queue (Min-Heap)</li>
                        <li><strong>Graph Type:</strong> Weighted graphs with non-negative edges</li>
                        <li><strong>Time Complexity:</strong> <span class="highlight">O((V + E) log V)</span> with binary heap</li>
                        <li><strong>Space Complexity:</strong> <span class="highlight">O(V)</span></li>
                        <li><strong>Optimality:</strong> Guaranteed to find shortest paths</li>
                    </ul>
                    
                    <h3>Applications</h3>
                    <ul>
                        <li><strong>GPS Navigation:</strong> Finding shortest routes in road networks</li>
                        <li><strong>Network Routing:</strong> OSPF, IS-IS protocols use Dijkstra's algorithm</li>
                        <li><strong>Google Maps:</strong> Route optimization</li>
                        <li><strong>Robotics:</strong> Path planning for autonomous robots</li>
                        <li><strong>Airline Systems:</strong> Finding cheapest flight routes</li>
                        <li><strong>Telephone Networks:</strong> Routing calls efficiently</li>
                        <li><strong>Social Networks:</strong> Finding shortest connection paths</li>
                    </ul>
                    
                    <h3>Advantages</h3>
                    <ul>
                        <li>Guaranteed optimal solution for non-negative weights</li>
                        <li>Efficient with proper data structures</li>
                        <li>Widely applicable to real-world problems</li>
                        <li>Can be stopped once target is reached</li>
                        <li>Works on both directed and undirected graphs</li>
                    </ul>
                    
                    <h3>Disadvantages</h3>
                    <ul>
                        <li>Doesn't work with negative edge weights</li>
                        <li>Can be slow on dense graphs</li>
                        <li>Explores all directions equally (not goal-directed)</li>
                        <li>Requires priority queue for efficiency</li>
                    </ul>
                `,
                theory: `
                    <h2>Dijkstra's Algorithm Theory</h2>
                    
                    <h3>Algorithm Overview</h3>
                    <p>Dijkstra's algorithm maintains a set S of vertices whose final shortest-path weights have been determined. It repeatedly selects the vertex with minimum shortest-path estimate, adds it to S, and relaxes all edges leaving it.</p>
                    
                    <h3>Key Concepts</h3>
                    <ul>
                        <li><strong>Set S:</strong> Vertices with finalized shortest paths</li>
                        <li><strong>Priority Queue Q:</strong> Vertices not in S, ordered by distance</li>
                        <li><strong>d[v]:</strong> Current shortest-path estimate from source to v</li>
                        <li><strong>œÄ[v]:</strong> Predecessor of v in shortest path</li>
                    </ul>
                    
                    <h3>Relaxation Operation</h3>
                    <p>Edge relaxation is the process of updating the shortest-path estimate:</p>
                    <div class="algorithm-box">
RELAX(u, v, w)
1  if d[v] > d[u] + w(u, v)
2      d[v] ‚Üê d[u] + w(u, v)
3      œÄ[v] ‚Üê u
                    </div>
                    
                    <h3>Dijkstra's Algorithm Pseudocode</h3>
                    <div class="algorithm-box">
DIJKSTRA(G, w, s)
1  INITIALIZE-SINGLE-SOURCE(G, s)
2  S ‚Üê ‚àÖ
3  Q ‚Üê V[G]
4  while Q ‚â† ‚àÖ
5      u ‚Üê EXTRACT-MIN(Q)
6      S ‚Üê S ‚à™ {u}
7      for each vertex v ‚àà Adj[u]
8          RELAX(u, v, w)

INITIALIZE-SINGLE-SOURCE(G, s)
1  for each vertex v ‚àà V[G]
2      d[v] ‚Üê ‚àû
3      œÄ[v] ‚Üê NIL
4  d[s] ‚Üê 0
                    </div>
                    
                    <h3>How Dijkstra Works</h3>
                    <ul>
                        <li><strong>Initialize:</strong> Set source distance to 0, all others to ‚àû</li>
                        <li><strong>Extract-Min:</strong> Remove vertex with smallest distance from Q</li>
                        <li><strong>Add to S:</strong> Add extracted vertex to set of finalized vertices</li>
                        <li><strong>Relax:</strong> Update distances of all neighbors if shorter path found</li>
                        <li><strong>Repeat:</strong> Continue until Q is empty</li>
                    </ul>
                    
                    <h3>Greedy Choice Property</h3>
                    <p>The algorithm makes the locally optimal choice at each step (selecting minimum distance vertex), which leads to a globally optimal solution.</p>
                    
                    <h3>Correctness Proof</h3>
                    <p>Loop Invariant: At the start of each iteration, d[v] = Œ¥(s, v) for all v ‚àà S, where Œ¥(s, v) is the actual shortest-path distance.</p>
                    
                    <h3>Time Complexity Analysis</h3>
                    <ul>
                        <li><strong>With Array:</strong> O(V¬≤) - suitable for dense graphs</li>
                        <li><strong>With Binary Heap:</strong> O((V + E) log V) - good for sparse graphs</li>
                        <li><strong>With Fibonacci Heap:</strong> O(V log V + E) - theoretical best</li>
                    </ul>
                `,
                procedure: `
                    <h2>Procedure to Perform Dijkstra Simulation</h2>
                    
                    <div class="procedure-step">
                        <h4>Step 1: Understand the Weighted Graph</h4>
                        <p>The graph displays vertices with weighted edges. Each edge has a positive number indicating its weight (cost/distance). The goal is to find shortest paths from source to all vertices.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 2: Select Source Vertex</h4>
                        <p>Choose a source vertex (typically 's') from the dropdown. This is the starting point from which shortest paths to all other vertices will be computed.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 3: Initialize Algorithm</h4>
                        <p>Click "Next Step" to initialize:</p>
                        <ul>
                            <li>Source vertex gets distance 0</li>
                            <li>All other vertices get distance ‚àû</li>
                            <li>All vertices are added to priority queue Q</li>
                            <li>Set S (finalized vertices) starts empty</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 4: Extract Minimum Distance Vertex</h4>
                        <p>Continue clicking "Next Step". The algorithm will:</p>
                        <ul>
                            <li>Extract vertex with minimum distance from Q</li>
                            <li>Move it from Q to set S</li>
                            <li>Vertex color changes to BLACK (finalized)</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 5: Relax Adjacent Edges</h4>
                        <p>For the extracted vertex u, the algorithm relaxes all outgoing edges:</p>
                        <ul>
                            <li>For each neighbor v of u</li>
                            <li>Check if d[u] + weight(u,v) < d[v]</li>
                            <li>If yes, update d[v] = d[u] + weight(u,v)</li>
                            <li>Update v's position in priority queue</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 6: Monitor Key Information</h4>
                        <p>While stepping through:</p>
                        <ul>
                            <li><strong>Priority Queue Q:</strong> Shows vertices awaiting processing with current distances</li>
                            <li><strong>Set S:</strong> Shows finalized vertices with confirmed shortest distances</li>
                            <li><strong>Distance Labels:</strong> Each vertex displays d=value</li>
                            <li><strong>Step Info:</strong> Explains relaxation operations</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 7: Observe Relaxation Details</h4>
                        <p>When distances are updated, the step info shows:</p>
                        <ul>
                            <li>Which vertex was extracted</li>
                            <li>Which edges were relaxed</li>
                            <li>New distance calculations: "v(old+weight=new)"</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 8: Verify Final Results</h4>
                        <p>When algorithm completes:</p>
                        <ul>
                            <li>Priority queue Q is empty</li>
                            <li>All vertices are in set S</li>
                            <li>Each vertex shows its shortest distance from source</li>
                            <li>All distances are optimal (no shorter path exists)</li>
                        </ul>
                    </div>
                    
                    <h3>Understanding Relaxation</h3>
                    <p>Relaxation is the key operation:</p>
                    <ul>
                        <li>Tests whether going through u improves shortest path to v</li>
                        <li>If d[u] + weight(u,v) < d[v], then update d[v]</li>
                        <li>This is the "greedy" step - always taking the locally best choice</li>
                    </ul>
                    
                    <h3>Experiment Ideas</h3>
                    <ul>
                        <li>Try different source vertices and compare results</li>
                        <li>Observe how the greedy choice leads to optimal solution</li>
                        <li>Track how priority queue maintains ordering</li>
                        <li>Verify triangle inequality: d[v] ‚â§ d[u] + weight(u,v)</li>
                    </ul>
                `
            },
            astar: {
                about: `
                    <h2>About A* Search Algorithm</h2>
                    
                    <p>A* (pronounced "A-star") is an informed search algorithm that uses heuristics to efficiently find shortest paths. It combines the benefits of Dijkstra's algorithm with goal-directed search using heuristic functions. Developed by Peter Hart, Nils Nilsson, and Bertram Raphael in 1968.</p>
                    
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Strategy:</strong> Best-first search with heuristics</li>
                        <li><strong>Evaluation Function:</strong> <span class="highlight">f(n) = g(n) + h(n)</span></li>
                        <li><strong>Data Structures:</strong> Open list (priority queue) and Closed list</li>
                        <li><strong>Graph Type:</strong> Weighted graphs</li>
                        <li><strong>Optimality:</strong> Optimal if heuristic is admissible</li>
                        <li><strong>Efficiency:</strong> More efficient than Dijkstra when good heuristic available</li>
                    </ul>
                    
                    <h3>Applications</h3>
                    <ul>
                        <li><strong>Video Games:</strong> Pathfinding for NPCs and characters</li>
                        <li><strong>Robotics:</strong> Navigation and motion planning</li>
                        <li><strong>AI Planning:</strong> Finding optimal action sequences</li>
                        <li><strong>Puzzle Solving:</strong> 15-puzzle, Rubik's cube, sliding puzzles</li>
                        <li><strong>Route Planning:</strong> GPS with traffic and real-time conditions</li>
                        <li><strong>Natural Language Processing:</strong> Parsing and speech recognition</li>
                        <li><strong>Computer Vision:</strong> Image segmentation</li>
                    </ul>
                    
                    <h3>Advantages</h3>
                    <ul>
                        <li>Optimal and complete with admissible heuristic</li>
                        <li>More efficient than uninformed search</li>
                        <li>Flexible - can use different heuristics</li>
                        <li>Widely used in practice</li>
                        <li>Guarantees shortest path with good heuristic</li>
                    </ul>
                    
                    <h3>Disadvantages</h3>
                    <ul>
                        <li>Requires good heuristic function</li>
                        <li>Can use significant memory</li>
                        <li>Performance depends on heuristic quality</li>
                        <li>May explore many nodes if heuristic is poor</li>
                    </ul>
                `,
                theory: `
                    <h2>A* Algorithm Theory</h2>
                    
                    <h3>Evaluation Function</h3>
                    <p>A* uses the evaluation function:</p>
                    <p><span class="highlight">f(n) = g(n) + h(n)</span></p>
                    <ul>
                        <li><strong>g(n):</strong> Actual cost from start node to node n</li>
                        <li><strong>h(n):</strong> Heuristic estimate of cost from n to goal</li>
                        <li><strong>f(n):</strong> Estimated total cost of path through n</li>
                    </ul>
                    
                    <h3>Heuristic Functions</h3>
                    <p>Common heuristics for grid-based pathfinding:</p>
                    <ul>
                        <li><strong>Euclidean Distance:</strong> h(n) = ‚àö((x‚ÇÅ-x‚ÇÇ)¬≤ + (y‚ÇÅ-y‚ÇÇ)¬≤)</li>
                        <li><strong>Manhattan Distance:</strong> h(n) = |x‚ÇÅ-x‚ÇÇ| + |y‚ÇÅ-y‚ÇÇ|</li>
                        <li><strong>Chebyshev Distance:</strong> h(n) = max(|x‚ÇÅ-x‚ÇÇ|, |y‚ÇÅ-y‚ÇÇ|)</li>
                        <li><strong>Octile Distance:</strong> Combines diagonal and straight moves</li>
                    </ul>
                    
                    <h3>Admissibility and Consistency</h3>
                    <ul>
                        <li><strong>Admissible:</strong> h(n) never overestimates actual cost to goal</li>
                        <li><strong>Consistent:</strong> h(n) ‚â§ c(n,n') + h(n') for every edge (n,n')</li>
                        <li><strong>Result:</strong> If h is admissible and consistent, A* is optimal</li>
                    </ul>
                    
                    <h3>A* Algorithm Pseudocode</h3>
                    <div class="algorithm-box">
A*(start, goal, h)
1  openSet ‚Üê {start}
2  closedSet ‚Üê ‚àÖ
3  g[start] ‚Üê 0
4  f[start] ‚Üê h(start)
5  while openSet ‚â† ‚àÖ
6      current ‚Üê node in openSet with lowest f value
7      if current = goal
8          return reconstruct_path(current)
9      remove current from openSet
10     add current to closedSet
11     for each neighbor of current
12         if neighbor in closedSet
13             continue
14         tentative_g ‚Üê g[current] + distance(current, neighbor)
15         if neighbor not in openSet
16             add neighbor to openSet
17         else if tentative_g ‚â• g[neighbor]
18             continue
19         g[neighbor] ‚Üê tentative_g
20         f[neighbor] ‚Üê g[neighbor] + h(neighbor)
21         parent[neighbor] ‚Üê current
                    </div>
                    
                    <h3>How A* Works</h3>
                    <ul>
                        <li><strong>Initialize:</strong> Add start to open list with f(start) = h(start)</li>
                        <li><strong>Select:</strong> Choose node with lowest f value from open list</li>
                        <li><strong>Goal Test:</strong> If it's the goal, reconstruct and return path</li>
                        <li><strong>Expand:</strong> Move to closed list, examine neighbors</li>
                        <li><strong>Update:</strong> For each neighbor, calculate g and f values</li>
                        <li><strong>Repeat:</strong> Continue until goal found or open list empty</li>
                    </ul>
                    
                    <h3>A* vs Dijkstra</h3>
                    <ul>
                        <li><strong>Dijkstra:</strong> A* with h(n) = 0 (explores all directions)</li>
                        <li><strong>A*:</strong> Uses heuristic to focus search toward goal</li>
                        <li><strong>Efficiency:</strong> A* explores fewer nodes with good heuristic</li>
                        <li><strong>Optimality:</strong> Both optimal, but A* is faster</li>
                    </ul>
                    
                    <h3>Properties</h3>
                    <ul>
                        <li><strong>Completeness:</strong> Always finds solution if one exists</li>
                        <li><strong>Optimality:</strong> Finds optimal solution with admissible heuristic</li>
                        <li><strong>Time:</strong> Exponential in worst case, but typically much faster</li>
                        <li><strong>Space:</strong> Stores all generated nodes - can be memory intensive</li>
                    </ul>
                `,
                procedure: `
                    <h2>Procedure to Perform A* Simulation</h2>
                    
                    <div class="procedure-step">
                        <h4>Step 1: Understand the Setup</h4>
                        <p>The graph shows weighted edges and heuristic values. Each vertex displays h(n) - the estimated distance to the goal. The algorithm will use both actual costs (g) and heuristic estimates (h) to find the optimal path.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 2: Select Start and Goal</h4>
                        <p>Choose two vertices:</p>
                        <ul>
                            <li><strong>Start Vertex:</strong> Where the search begins (e.g., 'S')</li>
                            <li><strong>Goal Vertex:</strong> The target destination (e.g., 'G')</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 3: Initialize A*</h4>
                        <p>Click "Next Step" to initialize:</p>
                        <ul>
                            <li>Start node: g=0, f=h(start), added to open list</li>
                            <li>All other nodes: g=‚àû, f=‚àû</li>
                            <li>Closed list starts empty</li>
                            <li>Start node colored in open list color</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 4: Select Node with Lowest f</h4>
                        <p>Continue clicking "Next Step". The algorithm:</p>
                        <ul>
                            <li>Selects node with minimum f(n) from open list</li>
                            <li>Checks if it's the goal (if yes, done!)</li>
                            <li>Moves it from open list to closed list</li>
                            <li>Node turns to closed list color (purple)</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 5: Expand Neighbors</h4>
                        <p>For current node, examine each neighbor:</p>
                        <ul>
                            <li>Skip if already in closed list</li>
                            <li>Calculate tentative_g = g(current) + edge_weight</li>
                            <li>If neighbor not in open list, add it</li>
                            <li>If tentative_g < g(neighbor), update:</li>
                            <ul>
                                <li>g(neighbor) = tentative_g</li>
                                <li>f(neighbor) = g(neighbor) + h(neighbor)</li>
                                <li>parent(neighbor) = current</li>
                            </ul>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 6: Monitor Key Displays</h4>
                        <ul>
                            <li><strong>Open List:</strong> Nodes to be evaluated (yellow), shows f values</li>
                            <li><strong>Closed List:</strong> Already evaluated nodes (purple), shows f values</li>
                            <li><strong>Vertex Labels:</strong> Show h, f, and g values</li>
                            <li><strong>Step Info:</strong> Details about current operation</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 7: Understand Value Updates</h4>
                        <p>On each vertex, observe:</p>
                        <ul>
                            <li><strong>h value:</strong> Static heuristic (doesn't change)</li>
                            <li><strong>g value:</strong> Updates when better path found</li>
                            <li><strong>f value:</strong> f = g + h (total estimate)</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 8: Goal Reached</h4>
                        <p>When algorithm finds the goal:</p>
                        <ul>
                            <li>Complete path is displayed</li>
                            <li>Path format: Start ‚Üí ... ‚Üí Goal</li>
                            <li>This is the optimal path</li>
                            <li>Total cost is g(goal)</li>
                        </ul>
                    </div>
                    
                    <h3>Understanding the Heuristic</h3>
                    <ul>
                        <li><strong>h(n) = 0:</strong> A* becomes Dijkstra (explores all directions)</li>
                        <li><strong>h(n) accurate:</strong> A* explores fewer nodes</li>
                        <li><strong>h(n) admissible:</strong> A* guarantees optimal path</li>
                        <li><strong>h(n) consistent:</strong> A* is even more efficient</li>
                    </ul>
                    
                    <h3>Observing A* Efficiency</h3>
                    <ul>
                        <li>Compare number of explored nodes with Dijkstra</li>
                        <li>Notice how A* focuses search toward goal</li>
                        <li>Observe that open list prioritizes promising nodes</li>
                        <li>Verify that final path is optimal</li>
                    </ul>
                    
                    <h3>Experiment Ideas</h3>
                    <ul>
                        <li>Try different start-goal pairs</li>
                        <li>Compare paths and exploration patterns</li>
                        <li>Observe how heuristic guides the search</li>
                        <li>Count nodes explored vs. total nodes</li>
                    </ul>
                `
            },
            prim: {
                about: `
                    <h2>About Prim's Algorithm</h2>
                    
                    <p>Prim's algorithm is a greedy algorithm that finds a Minimum Spanning Tree (MST) for a weighted undirected graph. It builds the MST by growing a single tree, starting from an arbitrary vertex and repeatedly adding the cheapest edge that connects a vertex in the tree to a vertex outside the tree.</p>
                    
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Purpose:</strong> Finds Minimum Spanning Tree</li>
                        <li><strong>Strategy:</strong> Greedy approach (similar to Dijkstra)</li>
                        <li><strong>Data Structure:</strong> Priority Queue (Min-Heap)</li>
                        <li><strong>Graph Type:</strong> Weighted, undirected, connected graphs</li>
                        <li><strong>Time Complexity:</strong> <span class="highlight">O((V + E) log V)</span> with binary heap</li>
                        <li><strong>Space Complexity:</strong> <span class="highlight">O(V)</span></li>
                    </ul>
                    
                    <h3>What is a Spanning Tree?</h3>
                    <ul>
                        <li>A subgraph that includes all vertices</li>
                        <li>Is a tree (connected and acyclic)</li>
                        <li>Has exactly V-1 edges for V vertices</li>
                    </ul>
                    
                    <h3>What is a Minimum Spanning Tree (MST)?</h3>
                    <ul>
                        <li>A spanning tree with minimum total edge weight</li>
                        <li>May not be unique (multiple MSTs possible)</li>
                        <li>Used to minimize connection costs</li>
                    </ul>
                    
                    <h3>Applications</h3>
                    <ul>
                        <li><strong>Network Design:</strong> Designing least-cost networks (telecommunications, electrical grids)</li>
                        <li><strong>Cluster Analysis:</strong> Single-linkage clustering in data mining</li>
                        <li><strong>Approximation Algorithms:</strong> Traveling Salesman Problem approximation</li>
                        <li><strong>Image Segmentation:</strong> Computer vision applications</li>
                        <li><strong>Handwriting Recognition:</strong> Feature extraction</li>
                        <li><strong>Routing Protocols:</strong> Network routing optimization</li>
                    </ul>
                    
                    <h3>Advantages</h3>
                    <ul>
                        <li>Simple and easy to implement</li>
                        <li>Works well on dense graphs</li>
                        <li>Efficient with proper data structures</li>
                        <li>Finds optimal MST</li>
                        <li>Can start from any vertex</li>
                    </ul>
                    
                    <h3>Disadvantages</h3>
                    <ul>
                        <li>Requires connected graph</li>
                        <li>Slower than Kruskal on sparse graphs</li>
                        <li>Requires priority queue for efficiency</li>
                    </ul>
                `,
                theory: `
                    <h2>Prim's Algorithm Theory</h2>
                    
                    <h3>Algorithm Overview</h3>
                    <p>Prim's algorithm grows the MST by starting with an arbitrary vertex and repeatedly adding the minimum-weight edge that connects a vertex in the MST to a vertex outside it.</p>
                    
                    <h3>Key Concepts</h3>
                    <ul>
                        <li><strong>MST Set:</strong> Vertices already included in the MST</li>
                        <li><strong>Priority Queue:</strong> Vertices not yet in MST, ordered by key value</li>
                        <li><strong>key[v]:</strong> Minimum weight edge connecting v to MST</li>
                        <li><strong>parent[v]:</strong> Parent of v in the MST</li>
                    </ul>
                    
                    <h3>Greedy Choice Property</h3>
                    <p>At each step, Prim's algorithm makes the locally optimal choice (minimum weight edge to grow the tree), which leads to a globally optimal solution (minimum spanning tree).</p>
                    
                    <h3>Prim's Algorithm Pseudocode</h3>
                    <div class="algorithm-box">
PRIM(G, w, r)
1  for each u ‚àà V[G]
2      key[u] ‚Üê ‚àû
3      parent[u] ‚Üê NIL
4  key[r] ‚Üê 0
5  Q ‚Üê V[G]
6  while Q ‚â† ‚àÖ
7      u ‚Üê EXTRACT-MIN(Q)
8      for each v ‚àà Adj[u]
9          if v ‚àà Q and w(u, v) < key[v]
10             parent[v] ‚Üê u
11             key[v] ‚Üê w(u, v)
                    </div>
                    
                    <h3>How Prim's Works</h3>
                    <ul>
                        <li><strong>Initialize:</strong> Set all keys to ‚àû, start vertex key to 0</li>
                        <li><strong>Extract-Min:</strong> Remove vertex with minimum key from priority queue</li>
                        <li><strong>Update Keys:</strong> For each adjacent vertex still in queue, update key if edge weight is smaller</li>
                        <li><strong>Update Parent:</strong> Track parent to reconstruct MST</li>
                        <li><strong>Repeat:</strong> Continue until all vertices processed</li>
                    </ul>
                    
                    <h3>Similarity to Dijkstra's Algorithm</h3>
                    <ul>
                        <li>Both use priority queue and greedy approach</li>
                        <li><strong>Dijkstra:</strong> key[v] = distance from source to v</li>
                        <li><strong>Prim:</strong> key[v] = minimum edge weight connecting v to MST</li>
                    </ul>
                    
                    <h3>Correctness</h3>
                    <p>Prim's algorithm is correct because:</p>
                    <ul>
                        <li>The MST property: A safe edge can always be added to grow the MST</li>
                        <li>Prim's always chooses a safe edge (minimum weight crossing the cut)</li>
                        <li>The greedy choice leads to an optimal solution</li>
                    </ul>
                    
                    <h3>Time Complexity Analysis</h3>
                    <ul>
                        <li><strong>With Binary Heap:</strong> O((V + E) log V)</li>
                        <li><strong>With Fibonacci Heap:</strong> O(E + V log V)</li>
                        <li><strong>With Array:</strong> O(V¬≤) - good for dense graphs</li>
                    </ul>
                    
                    <h3>MST Properties</h3>
                    <ul>
                        <li>Has exactly V-1 edges</li>
                        <li>Removing any edge disconnects the tree</li>
                        <li>Adding any edge creates exactly one cycle</li>
                        <li>Total weight is minimum among all spanning trees</li>
                    </ul>
                `,
                procedure: `
                    <h2>Procedure to Perform Prim's Algorithm Simulation</h2>
                    
                    <div class="procedure-step">
                        <h4>Step 1: Understand the Graph</h4>
                        <p>The weighted, undirected graph displays vertices and edges with weights. The goal is to find a subset of edges that connects all vertices with minimum total weight.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 2: Select Starting Vertex</h4>
                        <p>Choose any vertex as the starting point. Prim's algorithm can start from any vertex and will produce the same total MST weight (though the tree structure may differ).</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 3: Initialize Algorithm</h4>
                        <p>Click "Next Step" to initialize:</p>
                        <ul>
                            <li>Starting vertex gets key = 0</li>
                            <li>All other vertices get key = ‚àû</li>
                            <li>All vertices added to priority queue</li>
                            <li>MST set starts empty</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 4: Extract Minimum Key Vertex</h4>
                        <p>Continue clicking "Next Step":</p>
                        <ul>
                            <li>Extract vertex with minimum key from queue</li>
                            <li>Add it to the MST set</li>
                            <li>The edge connecting it (shown by parent) is part of MST</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 5: Update Adjacent Keys</h4>
                        <p>For the extracted vertex:</p>
                        <ul>
                            <li>Check all adjacent vertices still in queue</li>
                            <li>If edge weight < current key, update key</li>
                            <li>Update parent to track MST edges</li>
                            <li>Priority queue automatically reorders</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 6: Observe MST Growth</h4>
                        <p>Watch the MST grow:</p>
                        <ul>
                            <li><strong>MST Edges:</strong> Highlighted in green or bold</li>
                            <li><strong>Key Values:</strong> Shown on vertices</li>
                            <li><strong>Current MST Weight:</strong> Running total displayed</li>
                            <li><strong>Vertices in MST:</strong> Colored differently</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 7: Verify Completion</h4>
                        <p>When algorithm completes:</p>
                        <ul>
                            <li>All vertices are in MST set</li>
                            <li>Exactly V-1 edges selected</li>
                            <li>Total MST weight is displayed</li>
                            <li>Tree connects all vertices with minimum cost</li>
                        </ul>
                    </div>
                    
                    <h3>Understanding the Process</h3>
                    <ul>
                        <li><strong>Greedy Choice:</strong> Always pick minimum weight edge to grow tree</li>
                        <li><strong>Cut Property:</strong> Minimum edge crossing cut is safe to add</li>
                        <li><strong>Key Updates:</strong> Keep track of cheapest connection for each vertex</li>
                    </ul>
                    
                    <h3>Experiment Ideas</h3>
                    <ul>
                        <li>Start from different vertices - observe same total weight</li>
                        <li>Count edges - verify exactly V-1 edges selected</li>
                        <li>Compare with Kruskal's algorithm on same graph</li>
                        <li>Try graphs with equal-weight edges - multiple MSTs possible</li>
                    </ul>
                `
            },
            kruskal: {
                about: `
                    <h2>About Kruskal's Algorithm</h2>
                    
                    <p>Kruskal's algorithm is a greedy algorithm that finds a Minimum Spanning Tree (MST) by sorting all edges by weight and adding them one by one, skipping edges that would create cycles. It uses the Union-Find data structure to efficiently detect cycles.</p>
                    
                    <h3>Key Characteristics</h3>
                    <ul>
                        <li><strong>Purpose:</strong> Finds Minimum Spanning Tree</li>
                        <li><strong>Strategy:</strong> Greedy edge-based approach</li>
                        <li><strong>Data Structure:</strong> Union-Find (Disjoint Set Union)</li>
                        <li><strong>Graph Type:</strong> Weighted, undirected graphs (works on disconnected graphs)</li>
                        <li><strong>Time Complexity:</strong> <span class="highlight">O(E log E)</span> or O(E log V)</li>
                        <li><strong>Space Complexity:</strong> <span class="highlight">O(V)</span></li>
                    </ul>
                    
                    <h3>Key Difference from Prim's</h3>
                    <ul>
                        <li><strong>Prim's:</strong> Grows single tree, vertex-based</li>
                        <li><strong>Kruskal's:</strong> Builds forest of trees, edge-based</li>
                        <li><strong>Prim's:</strong> Better for dense graphs</li>
                        <li><strong>Kruskal's:</strong> Better for sparse graphs</li>
                    </ul>
                    
                    <h3>Applications</h3>
                    <ul>
                        <li><strong>Network Design:</strong> Minimum cost cable/pipe networks</li>
                        <li><strong>Cluster Analysis:</strong> Hierarchical clustering</li>
                        <li><strong>Image Processing:</strong> Segmentation algorithms</li>
                        <li><strong>Circuit Design:</strong> Minimizing wire length in VLSI</li>
                        <li><strong>Transportation:</strong> Minimum cost road networks</li>
                        <li><strong>Approximation:</strong> TSP and Steiner tree approximations</li>
                    </ul>
                    
                    <h3>Advantages</h3>
                    <ul>
                        <li>Simple conceptual understanding</li>
                        <li>Works on disconnected graphs (creates forest)</li>
                        <li>Efficient for sparse graphs</li>
                        <li>Easy to implement with Union-Find</li>
                        <li>Finds optimal MST</li>
                    </ul>
                    
                    <h3>Disadvantages</h3>
                    <ul>
                        <li>Requires sorting all edges first</li>
                        <li>Slower than Prim's on dense graphs</li>
                        <li>Need efficient Union-Find implementation</li>
                    </ul>
                `,
                theory: `
                    <h2>Kruskal's Algorithm Theory</h2>
                    
                    <h3>Algorithm Overview</h3>
                    <p>Kruskal's algorithm builds the MST by considering edges in ascending order of weight and adding them if they don't create a cycle. It uses Union-Find to efficiently detect cycles.</p>
                    
                    <h3>Union-Find Data Structure</h3>
                    <p>Also called Disjoint Set Union (DSU), this data structure maintains a collection of disjoint sets and supports two operations:</p>
                    <ul>
                        <li><strong>Find(x):</strong> Returns the representative (root) of the set containing x</li>
                        <li><strong>Union(x, y):</strong> Merges the sets containing x and y</li>
                    </ul>
                    
                    <h3>Union-Find Optimizations</h3>
                    <ul>
                        <li><strong>Path Compression:</strong> Make nodes point directly to root during Find</li>
                        <li><strong>Union by Rank:</strong> Attach smaller tree under larger tree</li>
                        <li><strong>Result:</strong> Nearly O(1) amortized time per operation</li>
                    </ul>
                    
                    <h3>Kruskal's Algorithm Pseudocode</h3>
                    <div class="algorithm-box">
KRUSKAL(G, w)
1  A ‚Üê ‚àÖ
2  for each vertex v ‚àà V[G]
3      MAKE-SET(v)
4  sort edges of E by weight w
5  for each edge (u, v) ‚àà E (in sorted order)
6      if FIND-SET(u) ‚â† FIND-SET(v)
7          A ‚Üê A ‚à™ {(u, v)}
8          UNION(u, v)
9  return A

MAKE-SET(x)
1  parent[x] ‚Üê x
2  rank[x] ‚Üê 0

FIND-SET(x)
1  if x ‚â† parent[x]
2      parent[x] ‚Üê FIND-SET(parent[x])
3  return parent[x]

UNION(x, y)
1  xRoot ‚Üê FIND-SET(x)
2  yRoot ‚Üê FIND-SET(y)
3  if rank[xRoot] < rank[yRoot]
4      parent[xRoot] ‚Üê yRoot
5  else if rank[xRoot] > rank[yRoot]
6      parent[yRoot] ‚Üê xRoot
7  else
8      parent[yRoot] ‚Üê xRoot
9      rank[xRoot] ‚Üê rank[xRoot] + 1
                    </div>
                    
                    <h3>How Kruskal's Works</h3>
                    <ul>
                        <li><strong>Initialize:</strong> Create singleton set for each vertex</li>
                        <li><strong>Sort Edges:</strong> Order all edges by increasing weight</li>
                        <li><strong>Process Edges:</strong> Consider each edge in sorted order</li>
                        <li><strong>Cycle Check:</strong> Use Find to check if endpoints in same set</li>
                        <li><strong>Add Edge:</strong> If no cycle, add edge and Union the sets</li>
                        <li><strong>Terminate:</strong> Stop when V-1 edges added (or all edges processed)</li>
                    </ul>
                    
                    <h3>Correctness</h3>
                    <p>Kruskal's algorithm is correct because:</p>
                    <ul>
                        <li>It follows the MST property: safe edges can be added</li>
                        <li>Minimum weight edge that doesn't create cycle is always safe</li>
                        <li>Greedy choice property holds for MST problem</li>
                        <li>Union-Find correctly detects cycles</li>
                    </ul>
                    
                    <h3>Time Complexity Analysis</h3>
                    <ul>
                        <li><strong>Sorting:</strong> O(E log E)</li>
                        <li><strong>Union-Find Operations:</strong> O(E Œ±(V)) ‚âà O(E)</li>
                        <li><strong>Total:</strong> O(E log E) dominated by sorting</li>
                        <li><strong>Since E ‚â§ V¬≤:</strong> log E = O(log V), so O(E log V)</li>
                    </ul>
                    
                    <h3>Cycle Detection</h3>
                    <p>An edge (u, v) creates a cycle if:</p>
                    <ul>
                        <li>Both u and v are already in the same component (same set)</li>
                        <li>FIND-SET(u) = FIND-SET(v)</li>
                        <li>Adding edge would create a cycle in that component</li>
                    </ul>
                    
                    <h3>Forest Evolution</h3>
                    <ul>
                        <li>Initially: V trees (each vertex is a tree)</li>
                        <li>Each edge addition: Merges two trees into one</li>
                        <li>After V-1 edges: Single tree (if graph connected)</li>
                        <li>If disconnected: Forest with multiple trees</li>
                    </ul>
                `,
                procedure: `
                    <h2>Procedure to Perform Kruskal's Algorithm Simulation</h2>
                    
                    <div class="procedure-step">
                        <h4>Step 1: Understand the Edge-Based Approach</h4>
                        <p>Unlike Prim's which grows a tree, Kruskal's considers edges globally. The graph shows all edges with their weights. The algorithm will process them from smallest to largest.</p>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 2: Initialize Union-Find</h4>
                        <p>Click "Next Step" to start:</p>
                        <ul>
                            <li>Each vertex starts in its own set (singleton)</li>
                            <li>Edges are sorted by weight (shown in sorted order)</li>
                            <li>MST edge set A starts empty</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 3: Process Edges in Order</h4>
                        <p>Continue clicking "Next Step":</p>
                        <ul>
                            <li>Current edge being considered is highlighted</li>
                            <li>Edge weight is displayed</li>
                            <li>Endpoints are checked for cycle</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 4: Cycle Detection with Find</h4>
                        <p>For each edge (u, v):</p>
                        <ul>
                            <li>Find the set representative of u</li>
                            <li>Find the set representative of v</li>
                            <li>If same representative: Edge would create cycle ‚Üí Skip</li>
                            <li>If different: Edge is safe ‚Üí Add to MST</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 5: Union Operation</h4>
                        <p>When edge is added:</p>
                        <ul>
                            <li>The two sets are merged (Union operation)</li>
                            <li>Edge is added to MST (shown in green/bold)</li>
                            <li>MST weight increases by edge weight</li>
                            <li>Component count decreases by 1</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 6: Monitor Key Information</h4>
                        <p>Observe during execution:</p>
                        <ul>
                            <li><strong>Sorted Edge List:</strong> All edges in order</li>
                            <li><strong>Current Edge:</strong> Edge being processed</li>
                            <li><strong>MST Edges:</strong> Edges accepted so far</li>
                            <li><strong>Rejected Edges:</strong> Edges that would create cycles</li>
                            <li><strong>Components:</strong> Number of disjoint sets remaining</li>
                            <li><strong>Total Weight:</strong> Sum of MST edge weights</li>
                        </ul>
                    </div>
                    
                    <div class="procedure-step">
                        <h4>Step 7: Verify Completion</h4>
                        <p>When algorithm completes:</p>
                        <ul>
                            <li>Exactly V-1 edges in MST (if graph connected)</li>
                            <li>All vertices connected by MST edges</li>
                            <li>Remaining edges shown as rejected</li>
                            <li>Total MST weight matches Prim's result</li>
                        </ul>
                    </div>
                    
                    <h3>Understanding Union-Find</h3>
                    <ul>
                        <li><strong>Initial State:</strong> Each vertex is its own parent</li>
                        <li><strong>After Union:</strong> Sets merge, share common root</li>
                        <li><strong>Path Compression:</strong> Nodes point to root after Find</li>
                        <li><strong>Efficiency:</strong> Nearly constant time per operation</li>
                    </ul>
                    
                    <h3>Observing the Forest</h3>
                    <ul>
                        <li>Start: V components (V separate trees)</li>
                        <li>Each edge: Merges 2 components into 1</li>
                        <li>End: 1 component (single spanning tree)</li>
                        <li>Watch components count decrease: V ‚Üí V-1 ‚Üí V-2 ‚Üí ... ‚Üí 1</li>
                    </ul>
                    
                    <h3>Experiment Ideas</h3>
                    <ul>
                        <li>Compare edge selection with Prim's algorithm</li>
                        <li>Observe how forests merge into single tree</li>
                        <li>Track rejected edges - they create cycles</li>
                        <li>Verify same MST weight as Prim's</li>
                        <li>Try on disconnected graph - creates MST forest</li>
                    </ul>
                `
            }
        };

        function selectAlgorithm(algo, event) {
            currentAlgorithm = algo;
            
            // Reset source and goal when changing algorithms
            source = null;
            goal = null;
            
            document.querySelectorAll('.algorithm-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            loadContent();
        }

        function showTab(tab, event) {
            currentTab = tab;
            
            document.querySelectorAll('.nav-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            loadContent();
        }

        function loadContent() {
            const contentArea = document.getElementById('contentArea');
            
            if (currentTab === 'simulation') {
                loadSimulation();
            } else if (currentTab === 'mcq') {
                loadMCQ();
            } else if (currentTab === 'applications') {
                loadApplications();
            } else {
                contentArea.innerHTML = `<div class="tab-content active">${algorithmContent[currentAlgorithm][currentTab]}</div>`;
            }
        }

        // MCQ Data for all algorithms
        const mcqData = {
            bfs: [
                {
                    question: "What data structure does BFS use?",
                    options: ["Stack", "Queue", "Priority Queue", "Linked List"],
                    correct: 1,
                    explanation: "BFS uses a FIFO Queue to maintain the order of vertices to be explored."
                },
                {
                    question: "What is the time complexity of BFS?",
                    options: ["O(V)", "O(E)", "O(V + E)", "O(V * E)"],
                    correct: 2,
                    explanation: "BFS visits each vertex once O(V) and explores each edge once O(E), giving O(V + E)."
                },
                {
                    question: "In which order does BFS explore vertices?",
                    options: ["Depth-first", "Level by level", "Random", "Alphabetical"],
                    correct: 1,
                    explanation: "BFS explores all vertices at distance k before exploring vertices at distance k+1."
                },
                {
                    question: "What color represents an undiscovered vertex in BFS?",
                    options: ["Gray", "Black", "White", "Red"],
                    correct: 2,
                    explanation: "WHITE represents undiscovered vertices in the BFS color scheme."
                },
                {
                    question: "BFS guarantees shortest path in which type of graphs?",
                    options: ["Weighted graphs", "Unweighted graphs", "Directed graphs only", "Cyclic graphs only"],
                    correct: 1,
                    explanation: "BFS finds shortest paths in unweighted graphs by exploring level by level."
                },
                {
                    question: "What does a GRAY vertex represent in BFS?",
                    options: ["Undiscovered", "Fully explored", "Discovered but not explored", "Starting vertex"],
                    correct: 2,
                    explanation: "GRAY vertices have been discovered but their neighbors haven't all been explored yet."
                },
                {
                    question: "What is the space complexity of BFS?",
                    options: ["O(1)", "O(V)", "O(E)", "O(V¬≤)"],
                    correct: 1,
                    explanation: "BFS requires O(V) space for the queue and color array."
                },
                {
                    question: "Which application is NOT suitable for BFS?",
                    options: ["Finding shortest path", "Web crawling", "Topological sorting", "Social network analysis"],
                    correct: 2,
                    explanation: "Topological sorting requires DFS, not BFS. BFS is ideal for shortest paths and level-based exploration."
                },
                {
                    question: "In BFS, what happens when a WHITE neighbor is found?",
                    options: ["It is ignored", "It is colored BLACK", "It is colored GRAY and enqueued", "It is colored RED"],
                    correct: 2,
                    explanation: "When a WHITE neighbor is discovered, it's colored GRAY and added to the queue for future exploration."
                },
                {
                    question: "What is the maximum number of vertices in the queue at any time during BFS?",
                    options: ["1", "V", "E", "V + E"],
                    correct: 1,
                    explanation: "In the worst case, all vertices could be in the queue, so maximum is O(V)."
                }
            ],
            dfs: [
                {
                    question: "DFS can be implemented using which data structure?",
                    options: ["Queue only", "Stack or recursion", "Array only", "Heap only"],
                    correct: 1,
                    explanation: "DFS uses a stack (implicit via recursion or explicit) for backtracking."
                },
                {
                    question: "What does d[v] represent in DFS?",
                    options: ["Distance from source", "Discovery time", "Degree of vertex", "Depth of vertex"],
                    correct: 1,
                    explanation: "d[v] is the discovery time - when vertex v is first discovered."
                },
                {
                    question: "What does f[v] represent in DFS?",
                    options: ["Function value", "Final distance", "Finishing time", "First neighbor"],
                    correct: 2,
                    explanation: "f[v] is the finishing time - when all neighbors of v have been explored."
                },
                {
                    question: "For any vertex u in DFS, which relationship is always true?",
                    options: ["d[u] > f[u]", "d[u] = f[u]", "d[u] < f[u]", "d[u] ‚â• f[u]"],
                    correct: 2,
                    explanation: "Discovery always happens before finishing, so d[u] < f[u] for all vertices."
                },
                {
                    question: "DFS is particularly useful for which of the following?",
                    options: ["Shortest path in weighted graphs", "Topological sorting", "Finding minimum spanning tree", "Level-order traversal"],
                    correct: 1,
                    explanation: "DFS is ideal for topological sorting, cycle detection, and finding strongly connected components."
                },
                {
                    question: "What is the time complexity of DFS?",
                    options: ["O(V)", "O(E)", "O(V + E)", "O(V¬≤)"],
                    correct: 2,
                    explanation: "DFS visits each vertex once and explores each edge once, giving O(V + E)."
                },
                {
                    question: "In DFS, what structure do discovery and finishing times have?",
                    options: ["Linear", "Parenthesis (nested)", "Random", "Circular"],
                    correct: 1,
                    explanation: "DFS timestamps have parenthesis structure - properly nested intervals."
                },
                {
                    question: "Which color indicates a vertex is currently being explored in DFS?",
                    options: ["WHITE", "GRAY", "BLACK", "BLUE"],
                    correct: 1,
                    explanation: "GRAY indicates a vertex is discovered but not yet finished."
                },
                {
                    question: "What edge type connects a vertex to its ancestor in DFS tree?",
                    options: ["Tree edge", "Back edge", "Forward edge", "Cross edge"],
                    correct: 1,
                    explanation: "Back edges connect a vertex to its ancestor in the DFS tree."
                },
                {
                    question: "DFS produces which structure?",
                    options: ["Single tree", "Depth-first forest", "Breadth-first tree", "Minimum spanning tree"],
                    correct: 1,
                    explanation: "DFS may produce a forest (multiple trees) if the graph is disconnected."
                }
            ],
            dijkstra: [
                {
                    question: "Dijkstra's algorithm works on graphs with which type of edge weights?",
                    options: ["Any weights", "Negative weights only", "Non-negative weights", "No weights"],
                    correct: 2,
                    explanation: "Dijkstra requires non-negative edge weights to guarantee correctness."
                },
                {
                    question: "What strategy does Dijkstra's algorithm use?",
                    options: ["Divide and conquer", "Dynamic programming", "Greedy", "Backtracking"],
                    correct: 2,
                    explanation: "Dijkstra uses a greedy strategy - always selecting the vertex with minimum distance."
                },
                {
                    question: "What does Set S represent in Dijkstra's algorithm?",
                    options: ["Source vertices", "Vertices with finalized shortest paths", "Unvisited vertices", "All vertices"],
                    correct: 1,
                    explanation: "Set S contains vertices whose final shortest-path weights have been determined."
                },
                {
                    question: "What is the time complexity with a binary heap?",
                    options: ["O(V¬≤)", "O(E log V)", "O((V+E) log V)", "O(V log E)"],
                    correct: 2,
                    explanation: "With binary heap, Dijkstra runs in O((V+E) log V) time."
                },
                {
                    question: "What operation updates distances in Dijkstra's algorithm?",
                    options: ["Extraction", "Insertion", "Relaxation", "Deletion"],
                    correct: 2,
                    explanation: "Edge relaxation checks if a shorter path exists and updates distances accordingly."
                },
                {
                    question: "In the relaxation step, when is d[v] updated?",
                    options: ["Always", "If d[v] < d[u] + w(u,v)", "If d[v] > d[u] + w(u,v)", "Never"],
                    correct: 2,
                    explanation: "Distance is updated if going through u provides a shorter path: d[v] > d[u] + w(u,v)."
                },
                {
                    question: "What data structure is used for efficient minimum extraction?",
                    options: ["Stack", "Queue", "Priority Queue", "Array"],
                    correct: 2,
                    explanation: "A priority queue (min-heap) efficiently extracts the vertex with minimum distance."
                },
                {
                    question: "Dijkstra's algorithm is optimal for which problem?",
                    options: ["Maximum flow", "Single-source shortest paths", "All-pairs shortest paths", "Minimum spanning tree"],
                    correct: 1,
                    explanation: "Dijkstra solves single-source shortest paths optimally for non-negative weights."
                },
                {
                    question: "What happens when Dijkstra encounters a negative edge?",
                    options: ["Works correctly", "May give incorrect results", "Stops execution", "Ignores the edge"],
                    correct: 1,
                    explanation: "Dijkstra may produce incorrect results with negative edges; use Bellman-Ford instead."
                },
                {
                    question: "Which vertices are in the priority queue Q?",
                    options: ["All vertices", "Vertices in S", "Vertices not in S (V - S)", "Only source"],
                    correct: 2,
                    explanation: "Queue Q contains vertices not yet in S (vertices whose shortest paths aren't finalized)."
                }
            ],
            astar: [
                {
                    question: "What is the evaluation function in A*?",
                    options: ["f(n) = g(n) - h(n)", "f(n) = g(n) + h(n)", "f(n) = g(n) * h(n)", "f(n) = h(n) / g(n)"],
                    correct: 1,
                    explanation: "A* uses f(n) = g(n) + h(n) where g is actual cost and h is heuristic estimate."
                },
                {
                    question: "What does g(n) represent in A*?",
                    options: ["Heuristic cost", "Total cost", "Actual cost from start to n", "Goal distance"],
                    correct: 2,
                    explanation: "g(n) is the actual cost of the path from start node to node n."
                },
                {
                    question: "What does h(n) represent in A*?",
                    options: ["Actual cost", "Heuristic estimate from n to goal", "Total cost", "Height of node"],
                    correct: 1,
                    explanation: "h(n) is the heuristic function estimating cost from n to the goal."
                },
                {
                    question: "What property must a heuristic have to guarantee optimality?",
                    options: ["Overestimates cost", "Admissible (never overestimates)", "Is always zero", "Is random"],
                    correct: 1,
                    explanation: "An admissible heuristic never overestimates the actual cost to reach the goal."
                },
                {
                    question: "When is A* more efficient than Dijkstra?",
                    options: ["Never", "When no heuristic available", "When good heuristic available", "Always"],
                    correct: 2,
                    explanation: "A* is more efficient when a good heuristic guides the search toward the goal."
                },
                {
                    question: "What does the open list contain in A*?",
                    options: ["Evaluated nodes", "Nodes to be evaluated", "Goal nodes", "Starting nodes"],
                    correct: 1,
                    explanation: "The open list contains nodes discovered but not yet evaluated."
                },
                {
                    question: "What does the closed list contain in A*?",
                    options: ["Unvisited nodes", "Nodes to visit", "Already evaluated nodes", "Heuristic values"],
                    correct: 2,
                    explanation: "The closed list contains nodes that have been fully evaluated."
                },
                {
                    question: "What is Manhattan distance?",
                    options: ["Straight line distance", "|x‚ÇÅ-x‚ÇÇ| + |y‚ÇÅ-y‚ÇÇ|", "‚àö((x‚ÇÅ-x‚ÇÇ)¬≤ + (y‚ÇÅ-y‚ÇÇ)¬≤)", "Maximum of differences"],
                    correct: 1,
                    explanation: "Manhattan distance is |x‚ÇÅ-x‚ÇÇ| + |y‚ÇÅ-y‚ÇÇ|, used for grid-based movement."
                },
                {
                    question: "If h(n) = 0 for all n, what does A* become?",
                    options: ["BFS", "DFS", "Dijkstra's algorithm", "Bellman-Ford"],
                    correct: 2,
                    explanation: "When h(n) = 0, A* becomes Dijkstra's algorithm (uniform cost search)."
                },
                {
                    question: "What does a consistent heuristic guarantee?",
                    options: ["Slow execution", "Optimal path with fewer node expansions", "Random paths", "Infinite loops"],
                    correct: 1,
                    explanation: "A consistent heuristic ensures optimality and that no node is re-expanded."
                }
            ],
            prim: [
                {
                    question: "What is the purpose of Prim's algorithm?",
                    options: ["Find shortest paths", "Find Minimum Spanning Tree", "Topological sorting", "Find maximum flow"],
                    correct: 1,
                    explanation: "Prim's algorithm finds the Minimum Spanning Tree (MST) of a weighted undirected graph."
                },
                {
                    question: "What data structure does Prim's algorithm use?",
                    options: ["Stack", "Queue", "Priority Queue", "Hash Table"],
                    correct: 2,
                    explanation: "Prim's uses a priority queue (min-heap) to efficiently extract the minimum key vertex."
                },
                {
                    question: "How many edges are in a spanning tree of V vertices?",
                    options: ["V", "V-1", "V+1", "2V"],
                    correct: 1,
                    explanation: "A spanning tree of V vertices has exactly V-1 edges."
                },
                {
                    question: "What does key[v] represent in Prim's algorithm?",
                    options: ["Distance from source", "Minimum edge weight connecting v to MST", "Degree of v", "Discovery time"],
                    correct: 1,
                    explanation: "key[v] represents the minimum weight edge connecting vertex v to the current MST."
                },
                {
                    question: "What is Prim's time complexity with binary heap?",
                    options: ["O(V¬≤)", "O(E log E)", "O((V+E) log V)", "O(V log V)"],
                    correct: 2,
                    explanation: "With binary heap, Prim's runs in O((V+E) log V) time."
                },
                {
                    question: "Which algorithm is Prim's most similar to?",
                    options: ["BFS", "DFS", "Dijkstra's", "Bellman-Ford"],
                    correct: 2,
                    explanation: "Prim's is structurally very similar to Dijkstra's algorithm, both using priority queues and greedy approach."
                },
                {
                    question: "Can Prim's algorithm start from any vertex?",
                    options: ["Yes, MST weight will be same", "No, must start from specific vertex", "Only from minimum degree vertex", "Only from maximum weight vertex"],
                    correct: 0,
                    explanation: "Prim's can start from any vertex and will produce an MST with the same total weight."
                },
                {
                    question: "When is Prim's algorithm preferred over Kruskal's?",
                    options: ["Sparse graphs", "Dense graphs", "Disconnected graphs", "Directed graphs"],
                    correct: 1,
                    explanation: "Prim's is more efficient for dense graphs where E is close to V¬≤."
                },
                {
                    question: "What happens when you remove an edge from MST?",
                    options: ["Nothing changes", "Graph becomes disconnected", "Creates a cycle", "Reduces weight"],
                    correct: 1,
                    explanation: "Removing any edge from MST disconnects the graph into two components."
                },
                {
                    question: "Is the MST unique?",
                    options: ["Always unique", "Never unique", "Unique only if all edge weights are different", "Depends on algorithm used"],
                    correct: 2,
                    explanation: "MST is unique if all edge weights are distinct. With equal weights, multiple MSTs may exist."
                }
            ],
            kruskal: [
                {
                    question: "What data structure is essential for Kruskal's algorithm?",
                    options: ["Priority Queue", "Stack", "Union-Find", "Hash Table"],
                    correct: 2,
                    explanation: "Kruskal's uses Union-Find (Disjoint Set Union) to detect cycles efficiently."
                },
                {
                    question: "What is the first step in Kruskal's algorithm?",
                    options: ["Pick any vertex", "Create sets for vertices", "Sort all edges by weight", "Build adjacency list"],
                    correct: 2,
                    explanation: "Kruskal's first sorts all edges in non-decreasing order of weight."
                },
                {
                    question: "When does Kruskal's algorithm skip an edge?",
                    options: ["If weight is too high", "If it creates a cycle", "If it's the longest edge", "If endpoints are adjacent"],
                    correct: 1,
                    explanation: "An edge is skipped if both endpoints are already in the same set (would create cycle)."
                },
                {
                    question: "What is the time complexity of Kruskal's algorithm?",
                    options: ["O(V¬≤)", "O(E log E)", "O(V log V)", "O(E + V)"],
                    correct: 1,
                    explanation: "Kruskal's complexity is O(E log E) dominated by sorting edges."
                },
                {
                    question: "What does the FIND operation do in Union-Find?",
                    options: ["Finds minimum edge", "Returns set representative", "Finds next vertex", "Finds cycle"],
                    correct: 1,
                    explanation: "FIND returns the representative (root) of the set containing the given element."
                },
                {
                    question: "What does the UNION operation do?",
                    options: ["Adds an edge", "Merges two sets", "Removes a vertex", "Sorts edges"],
                    correct: 1,
                    explanation: "UNION merges two disjoint sets into one set."
                },
                {
                    question: "When is Kruskal's preferred over Prim's?",
                    options: ["Dense graphs", "Sparse graphs", "Graphs with negative weights", "Directed graphs"],
                    correct: 1,
                    explanation: "Kruskal's is more efficient for sparse graphs where E is much less than V¬≤."
                },
                {
                    question: "Can Kruskal's algorithm work on disconnected graphs?",
                    options: ["Yes, creates MST forest", "No, requires connected graph", "Only with modifications", "Yes, but gives wrong result"],
                    correct: 0,
                    explanation: "Kruskal's works on disconnected graphs and produces a Minimum Spanning Forest."
                },
                {
                    question: "What is path compression in Union-Find?",
                    options: ["Removing long paths", "Making nodes point to root during FIND", "Compressing edge weights", "Shortening MST"],
                    correct: 1,
                    explanation: "Path compression makes all nodes on the path point directly to the root during FIND."
                },
                {
                    question: "How many components remain after Kruskal's finishes on connected graph?",
                    options: ["0", "1", "V", "V-1"],
                    correct: 1,
                    explanation: "After Kruskal's on connected graph, all vertices are in one component (single tree)."
                }
            ]
        };

        let selectedAnswers = {};
        let showingResults = false;

        function loadMCQ() {
            const contentArea = document.getElementById('contentArea');
            const questions = mcqData[currentAlgorithm];
            selectedAnswers = {};
            showingResults = false;
            
            let html = `
                <div class="tab-content active">
                    <h2>Multiple Choice Questions - ${currentAlgorithm.toUpperCase()}</h2>
                    <p style="margin-bottom: 25px;">Test your understanding of ${currentAlgorithm.toUpperCase()} with these interactive questions.</p>
                    
                    <div class="mcq-container">
            `;
            
            questions.forEach((q, index) => {
                html += `
                    <div class="mcq-question" data-question="${index}">
                        <h4>Question ${index + 1}: ${q.question}</h4>
                        <div class="mcq-options">
                `;
                
                q.options.forEach((option, optIndex) => {
                    html += `
                        <div class="mcq-option" onclick="selectOption(${index}, ${optIndex})" data-option="${optIndex}">
                            <strong>${String.fromCharCode(65 + optIndex)}.</strong> ${option}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                        <div class="mcq-explanation" id="explanation-${index}" style="display: none;"></div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <button class="submit-mcq" onclick="checkAnswers()">Submit All Answers</button>
                    <div id="mcqResult"></div>
                </div>
            `;
            
            contentArea.innerHTML = html;
        }

        function selectOption(questionIndex, optionIndex) {
            if (showingResults) return;
            
            selectedAnswers[questionIndex] = optionIndex;
            
            const question = document.querySelector(`[data-question="${questionIndex}"]`);
            question.querySelectorAll('.mcq-option').forEach((opt, idx) => {
                opt.classList.remove('selected');
                if (idx === optionIndex) {
                    opt.classList.add('selected');
                }
            });
        }

        function checkAnswers() {
            if (showingResults) return;
            
            const questions = mcqData[currentAlgorithm];
            let correct = 0;
            let attempted = Object.keys(selectedAnswers).length;
            
            questions.forEach((q, index) => {
                const question = document.querySelector(`[data-question="${index}"]`);
                const options = question.querySelectorAll('.mcq-option');
                const explanationDiv = document.getElementById(`explanation-${index}`);
                
                options.forEach((opt, idx) => {
                    opt.style.pointerEvents = 'none';
                    opt.classList.remove('selected');
                    
                    if (idx === q.correct) {
                        opt.classList.add('correct');
                    } else if (idx === selectedAnswers[index]) {
                        opt.classList.add('incorrect');
                    }
                });
                
                if (selectedAnswers[index] === q.correct) {
                    correct++;
                }
                
                explanationDiv.innerHTML = `
                    <div style="margin-top: 15px; padding: 12px; background: #2c2c2c; border-left: 4px solid ${selectedAnswers[index] === q.correct ? '#4caf50' : '#f44336'}; border-radius: 4px;">
                        <strong style="color: #1e88e5;">Explanation:</strong><br>
                        <span style="color: #c0c0c0;">${q.explanation}</span>
                    </div>
                `;
                explanationDiv.style.display = 'block';
            });
            
            const percentage = attempted > 0 ? (correct / questions.length * 100).toFixed(1) : 0;
            const resultDiv = document.getElementById('mcqResult');
            
            let resultColor, resultText;
            if (percentage >= 80) {
                resultColor = '#4caf50';
                resultText = 'Excellent!';
            } else if (percentage >= 60) {
                resultColor = '#ffc107';
                resultText = 'Good Job!';
            } else {
                resultColor = '#f44336';
                resultText = 'Keep Learning!';
            }
            
            resultDiv.innerHTML = `
                <div style="margin-top: 25px; padding: 20px; background: #2c2c2c; border-radius: 8px; text-align: center; border: 2px solid ${resultColor};">
                    <h3 style="color: ${resultColor}; margin-bottom: 15px;">${resultText}</h3>
                    <div style="font-size: 48px; font-weight: bold; color: ${resultColor}; margin: 15px 0;">${percentage}%</div>
                    <p style="font-size: 18px; color: #c0c0c0;">
                        You answered <strong style="color: #1e88e5;">${correct}</strong> out of <strong style="color: #1e88e5;">${questions.length}</strong> questions correctly
                    </p>
                    <p style="margin-top: 10px; color: #888;">
                        ${attempted < questions.length ? `You attempted ${attempted} questions. ` : ''}
                    </p>
                    <button onclick="resetMCQ()" style="margin-top: 20px; max-width: 300px;">Try Again</button>
                </div>
            `;
            
            showingResults = true;
        }

        function resetMCQ() {
            loadMCQ();
        }

        function loadSimulation() {
            const contentArea = document.getElementById('contentArea');
            
            // Check if A* to add goal selection
            const isAStar = currentAlgorithm === 'astar';
            
            let goalSelectHTML = '';
            if (isAStar) {
                goalSelectHTML = `
                    <div class="control-group">
                        <label>Select Goal</label>
                        <select id="goalSelect" onchange="selectGoal()">
                            <option value="">-- Select Goal --</option>
                        </select>
                    </div>
                `;
            }
            
            contentArea.innerHTML = `
                <div class="tab-content active">
                    <h2>${currentAlgorithm.toUpperCase()} Simulation</h2>
                    <div class="simulation-container">
                        <div class="canvas-section">
                            <h3>Graph Visualization</h3>
                            <canvas id="graphCanvas"></canvas>
                        </div>
                        <div class="controls-section">
                            <div class="control-group">
                                <label>Select Source</label>
                                <select id="sourceSelect">
                                    <option value="">-- Select --</option>
                                </select>
                            </div>
                            ${goalSelectHTML}
                            <div class="control-group">
                                <label>Controls</label>
                                <button onclick="nextStep()">Next Step</button>
                                <button onclick="prevStep()" id="prevBtn" disabled>Previous Step</button>
                                <button onclick="resetSim()">Reset</button>
                            </div>
                            <div class="info-box">
                                <h4>Legend</h4>
                                <div class="legend">
                                    <div class="legend-item"><div class="legend-color" style="background: white;"></div><span>Undiscovered</span></div>
                                    <div class="legend-item"><div class="legend-color" style="background: #ffd700;"></div><span>Discovered</span></div>
                                    <div class="legend-item"><div class="legend-color" style="background: #333;"></div><span>Explored</span></div>
                                </div>
                            </div>
                            <div class="display-box">
                                <h4>Queue</h4>
                                <div class="items-container" id="queueDisplay"><span style="color: #999;">Empty</span></div>
                            </div>
                            <div class="display-box">
                                <h4>Traversal Order</h4>
                                <div class="items-container" id="traversalDisplay"><span style="color: #999;">Not started</span></div>
                            </div>
                            <div class="stats">
                                <div class="stat-item"><div class="stat-label">Explored</div><div class="stat-value" id="exploredCount">0</div></div>
                                <div class="stat-item"><div class="stat-label">Step</div><div class="stat-value" id="stepCount">0</div></div>
                            </div>
                            <div class="step-info" id="stepInfo">Select a source vertex to begin</div>
                        </div>
                    </div>
                    
                    <!-- AI Tutor Section -->
                    <div class="ai-tutor-section">
                        <h3>ü§ñ AI Tutor</h3>
                        
                        <div class="ai-toggle">
                            <label>Enable AI Explanations</label>
                            <div class="toggle-switch active" id="aiToggle" onclick="toggleAI()"></div>
                        </div>
                        
                        <div class="ai-explanation-box" id="aiExplanationBox">
                            <h4>Step Explanation</h4>
                            <div class="ai-explanation-text" id="aiExplanationText">
                                <p>üëã Hi! I'm your AI tutor. I'll help you understand each step of the algorithm.</p>
                                <p>Select a source vertex and click "Next Step" to begin. I'll explain what's happening at each stage!</p>
                            </div>
                        </div>
                        
                        <div class="info-box" style="margin-top: auto;">
                            <h4 style="font-size: 12px;">üí° AI Features</h4>
                            <ul style="font-size: 11px; line-height: 1.6; color: #888; margin: 5px 0 0 15px;">
                                <li>Real-time step explanations</li>
                                <li>Key insights highlighted</li>
                                <li>Concept clarification</li>
                                <li>Adaptive language level</li>
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                initSimulation();
            }, 100);
        }

        class Vertex {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.color = 'WHITE';
                this.distance = Infinity;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 25, 0, 2 * Math.PI);
                
                if (this.color === 'WHITE') {
                    ctx.fillStyle = '#ffffff';
                } else if (this.color === 'GRAY') {
                    ctx.fillStyle = '#ffd700';
                } else {
                    ctx.fillStyle = '#333333';
                }
                
                ctx.fill();
                ctx.strokeStyle = '#1e88e5';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = this.color === 'BLACK' ? 'white' : 'black';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);

                if (this.distance !== Infinity) {
                    ctx.fillStyle = '#1e88e5';
                    ctx.font = 'bold 11px Arial';
                    ctx.fillText(`d=${this.distance}`, this.x, this.y + 35);
                }
            }
        }

        class Edge {
            constructor(v1, v2) {
                this.v1 = v1;
                this.v2 = v2;
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.v1.x, this.v1.y);
                ctx.lineTo(this.v2.x, this.v2.y);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function initSimulation() {
            canvas = document.getElementById('graphCanvas');
            if (!canvas) return;
            
            ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            createGraph();
        }

        function createGraph() {
            vertices = [];
            edges = [];
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const r = Math.min(canvas.width, canvas.height) * 0.25;
            
            // Different graph structures for different algorithms
            if (currentAlgorithm === 'bfs') {
                // BFS: Simple connected graph with clear levels
                const positions = [
                    {id: 'A', x: cx, y: cy - r},
                    {id: 'B', x: cx - r * 0.9, y: cy - r * 0.3},
                    {id: 'C', x: cx + r * 0.9, y: cy - r * 0.3},
                    {id: 'D', x: cx - r * 1.2, y: cy + r * 0.4},
                    {id: 'E', x: cx - r * 0.4, y: cy + r * 0.4},
                    {id: 'F', x: cx + r * 0.4, y: cy + r * 0.4},
                    {id: 'G', x: cx + r * 1.2, y: cy + r * 0.4},
                    {id: 'H', x: cx, y: cy + r * 1.0}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['A','B'],['A','C'],['B','D'],['B','E'],
                    ['C','F'],['C','G'],['E','H'],['F','H']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
                
            } else if (currentAlgorithm === 'dfs') {
                // DFS: Graph with clear depth structure
                const positions = [
                    {id: 'A', x: cx - r * 1.0, y: cy - r * 0.8},
                    {id: 'B', x: cx, y: cy - r * 0.8},
                    {id: 'C', x: cx + r * 1.0, y: cy - r * 0.8},
                    {id: 'D', x: cx - r * 1.0, y: cy + r * 0.2},
                    {id: 'E', x: cx, y: cy + r * 0.2},
                    {id: 'F', x: cx + r * 1.0, y: cy + r * 0.2},
                    {id: 'G', x: cx - r * 0.5, y: cy + r * 1.0},
                    {id: 'H', x: cx + r * 0.5, y: cy + r * 1.0}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['A','B'],['A','D'],['B','E'],['C','E'],
                    ['C','F'],['D','G'],['E','G'],['E','H'],['F','H']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
                
            } else if (currentAlgorithm === 'dijkstra') {
                // Dijkstra: Weighted graph with labeled vertices
                const positions = [
                    {id: 's', x: cx - r * 1.2, y: cy},
                    {id: 't', x: cx - r * 0.4, y: cy - r * 0.8},
                    {id: 'x', x: cx + r * 0.4, y: cy - r * 0.8},
                    {id: 'y', x: cx - r * 0.4, y: cy + r * 0.8},
                    {id: 'z', x: cx + r * 0.4, y: cy + r * 0.8}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['s','t'],['s','y'],['t','x'],['t','y'],
                    ['x','z'],['y','t'],['y','x'],['y','z'],['z','s'],['z','x']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
                
            } else if (currentAlgorithm === 'astar') {
                // A*: Path-finding oriented graph
                const positions = [
                    {id: 'S', x: cx - r * 1.3, y: cy},
                    {id: 'A', x: cx - r * 0.6, y: cy - r * 0.8},
                    {id: 'B', x: cx - r * 0.6, y: cy + r * 0.8},
                    {id: 'C', x: cx + r * 0.2, y: cy - r * 0.9},
                    {id: 'D', x: cx + r * 0.2, y: cy},
                    {id: 'E', x: cx + r * 0.2, y: cy + r * 0.9},
                    {id: 'G', x: cx + r * 1.1, y: cy}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['S','A'],['S','B'],['A','C'],['A','D'],
                    ['B','D'],['B','E'],['C','G'],['D','G'],['E','G']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
                
            } else if (currentAlgorithm === 'prim') {
                // Prim's: Weighted undirected graph for MST
                const positions = [
                    {id: 'A', x: cx - r * 1.0, y: cy - r * 0.7},
                    {id: 'B', x: cx, y: cy - r * 1.0},
                    {id: 'C', x: cx + r * 1.0, y: cy - r * 0.7},
                    {id: 'D', x: cx - r * 1.2, y: cy + r * 0.3},
                    {id: 'E', x: cx - r * 0.3, y: cy + r * 0.2},
                    {id: 'F', x: cx + r * 0.3, y: cy + r * 0.2},
                    {id: 'G', x: cx + r * 1.2, y: cy + r * 0.3},
                    {id: 'H', x: cx, y: cy + r * 1.0}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['A','B'],['A','D'],['A','E'],['B','C'],['B','E'],
                    ['C','F'],['C','G'],['D','E'],['E','F'],['E','H'],
                    ['F','G'],['F','H']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
                
            } else if (currentAlgorithm === 'kruskal') {
                // Kruskal's: Complete-ish graph for MST
                const positions = [
                    {id: 'A', x: cx - r * 0.8, y: cy - r * 0.8},
                    {id: 'B', x: cx + r * 0.8, y: cy - r * 0.8},
                    {id: 'C', x: cx - r * 1.2, y: cy + r * 0.2},
                    {id: 'D', x: cx - r * 0.4, y: cy + r * 0.2},
                    {id: 'E', x: cx + r * 0.4, y: cy + r * 0.2},
                    {id: 'F', x: cx + r * 1.2, y: cy + r * 0.2},
                    {id: 'G', x: cx - r * 0.5, y: cy + r * 1.0},
                    {id: 'H', x: cx + r * 0.5, y: cy + r * 1.0}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['A','B'],['A','C'],['A','D'],['B','E'],['B','F'],
                    ['C','D'],['D','E'],['D','G'],['E','F'],['E','H'],
                    ['F','H'],['G','H']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
            } else {
                // Default graph
                const positions = [
                    {id: 'A', x: cx, y: cy - r},
                    {id: 'B', x: cx - r * 0.7, y: cy - r * 0.5},
                    {id: 'C', x: cx + r * 0.7, y: cy - r * 0.5},
                    {id: 'D', x: cx - r, y: cy + r * 0.3},
                    {id: 'E', x: cx, y: cy + r * 0.3},
                    {id: 'F', x: cx + r, y: cy + r * 0.3}
                ];
                positions.forEach(p => vertices.push(new Vertex(p.id, p.x, p.y)));
                
                const connections = [
                    ['A','B'],['A','C'],['B','D'],['B','E'],
                    ['C','E'],['C','F'],['D','E'],['E','F']
                ];
                connections.forEach(c => {
                    const v1 = vertices.find(v => v.id === c[0]);
                    const v2 = vertices.find(v => v.id === c[1]);
                    if (v1 && v2) edges.push(new Edge(v1, v2));
                });
            }

            buildAdjList();
            updateSourceSelect();
            draw();
        }

        function buildAdjList() {
            adjList = {};
            vertices.forEach(v => adjList[v.id] = []);
            edges.forEach(e => {
                adjList[e.v1.id].push(e.v2);
                adjList[e.v2.id].push(e.v1);
            });
        }

        function draw() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            edges.forEach(e => e.draw());
            vertices.forEach(v => v.draw());
        }

        function updateSourceSelect() {
            const sel = document.getElementById('sourceSelect');
            if (!sel) return;
            sel.innerHTML = '<option value="">-- Select Source --</option>';
            vertices.forEach(v => {
                sel.innerHTML += `<option value="${v.id}">Vertex ${v.id}</option>`;
            });
            sel.onchange = selectSource;
            
            // Also populate goal select if it exists (for A*)
            const goalSel = document.getElementById('goalSelect');
            if (goalSel) {
                goalSel.innerHTML = '<option value="">-- Select Goal --</option>';
                vertices.forEach(v => {
                    goalSel.innerHTML += `<option value="${v.id}">Vertex ${v.id}</option>`;
                });
            }
        }

        function selectSource() {
            const sel = document.getElementById('sourceSelect');
            const id = sel.value;
            if (id) {
                source = vertices.find(v => v.id === id);
                resetSim();
                draw();
                if (currentAlgorithm === 'astar' && !goal) {
                    updateInfo(`Source ${id} selected. Now select a goal vertex.`);
                } else if (currentAlgorithm === 'astar' && goal) {
                    updateInfo(`Source ${id} and Goal ${goal.id} selected. Click Next Step to begin.`);
                } else {
                    updateInfo(`Source ${id} selected. Click Next Step to begin.`);
                }
            }
        }

        function selectGoal() {
            const sel = document.getElementById('goalSelect');
            const id = sel.value;
            if (id) {
                goal = vertices.find(v => v.id === id);
                resetSim();
                draw();
                if (source) {
                    updateInfo(`Source ${source.id} and Goal ${id} selected. Click Next Step to begin.`);
                } else {
                    updateInfo(`Goal ${id} selected. Now select a source vertex.`);
                }
            }
        }

        function nextStep() {
            if (!initialized) {
                if (!source) {
                    alert('Please select a source vertex first!');
                    return;
                }
                if (currentAlgorithm === 'astar' && !goal) {
                    alert('Please select a goal vertex for A* algorithm!');
                    return;
                }
                initBFS();
                
                // Generate AI explanation for initialization
                generateSimpleExplanation({
                    step: 0,
                    action: 'initialization',
                    vertex: source.id,
                    discovered: [],
                    queue: [source.id],
                    traversal: [],
                    graphState: 'initialized'
                });
                
                return;
            }
            
            if (historyIndex < history.length - 1) {
                restoreState(historyIndex + 1);
                return;
            }
            
            if (queue.length === 0) {
                updateInfo('BFS Complete! Traversal order: ' + traversal.join(' ‚Üí '));
                
                // Generate completion explanation
                generateSimpleExplanation({
                    step: step,
                    action: 'completion',
                    vertex: 'all',
                    discovered: [],
                    queue: [],
                    traversal: traversal,
                    graphState: 'complete'
                });
                
                return;
            }

            step++;
            const u = queue.shift();
            traversal.push(u.id);
            
            const adj = adjList[u.id];
            let discovered = [];

            adj.forEach(v => {
                if (v.color === 'WHITE') {
                    v.color = 'GRAY';
                    v.distance = u.distance + 1;
                    queue.push(v);
                    discovered.push(v.id);
                }
            });

            u.color = 'BLACK';
            explored++;

            if (discovered.length > 0) {
                updateInfo(`Step ${step}: Explored ${u.id}, discovered: ${discovered.join(', ')}`);
            } else {
                updateInfo(`Step ${step}: Explored ${u.id}, no new neighbors`);
            }
            
            saveState();
            updateDisplay();
            
            // Generate AI explanation for this step
            generateSimpleExplanation({
                step: step,
                action: 'explore',
                vertex: u.id,
                discovered: discovered,
                queue: queue.map(v => v.id),
                traversal: traversal,
                distance: u.distance,
                graphState: 'exploring'
            });
        }

        function prevStep() {
            if (historyIndex > 0) {
                restoreState(historyIndex - 1);
            }
        }

        function saveState() {
            const state = {
                vertices: vertices.map(v => ({
                    id: v.id,
                    color: v.color,
                    distance: v.distance
                })),
                queue: queue.map(v => v.id),
                explored: explored,
                step: step,
                traversal: [...traversal]
            };
            
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            history.push(state);
            historyIndex = history.length - 1;
            
            updateButtons();
        }

        function restoreState(index) {
            const state = history[index];
            historyIndex = index;
            
            state.vertices.forEach(vs => {
                const v = vertices.find(v => v.id === vs.id);
                if (v) {
                    v.color = vs.color;
                    v.distance = vs.distance;
                }
            });
            
            queue = state.queue.map(id => vertices.find(v => v.id === id)).filter(v => v);
            explored = state.explored;
            step = state.step;
            traversal = [...state.traversal];
            
            updateDisplay();
            updateInfo(`Step ${step}`);
            updateButtons();
        }

        function updateButtons() {
            const prevBtn = document.getElementById('prevBtn');
            if (prevBtn) {
                prevBtn.disabled = (historyIndex <= 0);
            }
        }

        function resetSim() {
            initialized = false;
            queue = [];
            explored = 0;
            step = 0;
            traversal = [];
            history = [];
            historyIndex = -1;
            
            vertices.forEach(v => {
                v.color = 'WHITE';
                v.distance = Infinity;
            });

            updateDisplay();
            draw();
            
            if (currentAlgorithm === 'astar' && source && goal) {
                updateInfo(`Reset. Source: ${source.id}, Goal: ${goal.id}. Click Next Step to begin.`);
            } else if (currentAlgorithm === 'astar' && source && !goal) {
                updateInfo('Reset. Source selected. Now select a goal vertex.');
            } else if (currentAlgorithm === 'astar' && !source && goal) {
                updateInfo('Reset. Goal selected. Now select a source vertex.');
            } else if (source) {
                updateInfo(`Reset. Source ${source.id} selected. Click Next Step to begin.`);
            } else {
                updateInfo('Reset. Select source vertex to begin.');
            }
            updateButtons();
        }

        function initBFS() {
            vertices.forEach(v => {
                v.color = 'WHITE';
                v.distance = Infinity;
            });

            source.color = 'GRAY';
            source.distance = 0;
            queue = [source];
            explored = 0;
            step = 0;
            traversal = [];
            history = [];
            historyIndex = -1;
            initialized = true;

            saveState();
            updateDisplay();
            
            if (currentAlgorithm === 'astar' && goal) {
                updateInfo(`A* initialized. Source: ${source.id}, Goal: ${goal.id}. Click Next Step to continue.`);
            } else {
                updateInfo(`${currentAlgorithm.toUpperCase()} initialized. Click Next Step to continue.`);
            }
        }

        function updateDisplay() {
            draw();
            
            const qDiv = document.getElementById('queueDisplay');
            if (qDiv) {
                if (queue.length === 0) {
                    qDiv.innerHTML = '<span style="color: #999;">Empty</span>';
                } else {
                    qDiv.innerHTML = queue.map(v => 
                        `<span class="item-badge">${v.id}</span>`
                    ).join('');
                }
            }
            
            const tDiv = document.getElementById('traversalDisplay');
            if (tDiv) {
                if (traversal.length === 0) {
                    tDiv.innerHTML = '<span style="color: #999;">Not started</span>';
                } else {
                    tDiv.innerHTML = traversal.map(id => 
                        `<span class="item-badge">${id}</span>`
                    ).join('');
                }
            }
            
            const eCount = document.getElementById('exploredCount');
            const sCount = document.getElementById('stepCount');
            if (eCount) eCount.textContent = explored;
            if (sCount) sCount.textContent = step;
        }

        function updateInfo(msg) {
            const info = document.getElementById('stepInfo');
            if (info) info.textContent = msg;
        }

        // ============================================
        // AI TUTOR FUNCTIONS
        // ============================================
        
        function toggleAI() {
            aiEnabled = !aiEnabled;
            const toggle = document.getElementById('aiToggle');
            if (toggle) {
                if (aiEnabled) {
                    toggle.classList.add('active');
                    showAIMessage('AI Tutor enabled! I\'ll explain each step as you progress.');
                } else {
                    toggle.classList.remove('active');
                    showAIMessage('AI Tutor disabled. Enable it anytime to get step explanations!');
                }
            }
        }
        
        function showAIMessage(message) {
            const aiText = document.getElementById('aiExplanationText');
            if (aiText) {
                aiText.innerHTML = `<p>${message}</p>`;
            }
        }
        
        function showAILoading() {
            const aiText = document.getElementById('aiExplanationText');
            if (aiText) {
                aiText.innerHTML = '<div class="ai-loading">Generating explanation...</div>';
            }
        }
        
        async function generateAIExplanation(stepData) {
            if (!aiEnabled) return;
            
            showAILoading();
            
            try {
                // Prepare context for AI
                const context = {
                    algorithm: currentAlgorithm.toUpperCase(),
                    step: stepData.step,
                    action: stepData.action,
                    vertex: stepData.vertex,
                    discovered: stepData.discovered,
                    queue: stepData.queue,
                    traversal: stepData.traversal,
                    graphState: stepData.graphState
                };
                
                // Create prompt for Claude API
                const prompt = createExplanationPrompt(context);
                
                // Call Claude API
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 500,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });
                
                const data = await response.json();
                
                if (data.content && data.content[0] && data.content[0].text) {
                    displayAIExplanation(data.content[0].text, context);
                } else {
                    showAIMessage('Unable to generate explanation at this moment.');
                }
            } catch (error) {
                console.error('AI Error:', error);
                showAIMessage('Error generating explanation. Continuing without AI assistance.');
            }
        }
        
        function createExplanationPrompt(context) {
            return `You are an AI tutor helping students learn graph algorithms. Explain this step in a clear, educational way.

Algorithm: ${context.algorithm}
Step Number: ${context.step}
Action: ${context.action}
Current Vertex: ${context.vertex || 'None'}
Discovered Vertices: ${context.discovered || 'None'}
Current Queue: ${context.queue || 'Empty'}

Provide a concise explanation (2-3 sentences) that:
1. Explains what just happened in this step
2. Highlights the key concept being demonstrated
3. Connects to the algorithm's theory

Keep it simple and encouraging for students. Use terms like "we", "notice", "this shows".`;
        }
        
        function displayAIExplanation(text, context) {
            const aiText = document.getElementById('aiExplanationText');
            if (!aiText) return;
            
            // Format the explanation nicely
            const formatted = `
                <div class="ai-insight">
                    <div class="ai-insight-label">üéØ STEP ${context.step} INSIGHT</div>
                    <p style="margin: 8px 0 0 0;">${text}</p>
                </div>
                
                <p style="margin-top: 12px; font-size: 12px; color: #888;">
                    <strong>Current State:</strong> ${context.traversal.length} vertices explored
                </p>
            `;
            
            aiText.innerHTML = formatted;
        }
        
        // Simpler version for when API is not available
        function generateSimpleExplanation(stepData) {
            if (!aiEnabled) return;
            
            const aiText = document.getElementById('aiExplanationText');
            if (!aiText) return;
            
            let explanation = '';
            
            switch(currentAlgorithm) {
                case 'bfs':
                    if (!initialized) {
                        explanation = `
                            <div class="ai-insight">
                                <div class="ai-insight-label">üéØ INITIALIZATION</div>
                                <p>We're starting BFS from vertex <strong>${stepData.vertex}</strong>. 
                                This vertex is now <span style="color: #ffd700;">GRAY</span> (discovered) and added to the queue. 
                                All other vertices remain <span style="color: white;">WHITE</span> (undiscovered).</p>
                            </div>
                            <p style="margin-top: 12px;"><strong>Key Concept:</strong> BFS explores vertices level by level, like ripples in water!</p>
                        `;
                    } else if (stepData.discovered && stepData.discovered.length > 0) {
                        explanation = `
                            <div class="ai-insight">
                                <div class="ai-insight-label">üéØ STEP ${stepData.step} - EXPLORING</div>
                                <p>We dequeued vertex <strong>${stepData.vertex}</strong> and discovered its neighbors: <strong>${stepData.discovered.join(', ')}</strong>. 
                                These new vertices turn <span style="color: #ffd700;">GRAY</span> and join the queue. 
                                Vertex ${stepData.vertex} is now <span style="color: #333;">BLACK</span> (fully explored).</p>
                            </div>
                            <p style="margin-top: 12px;"><strong>Notice:</strong> We're exploring all vertices at distance ${stepData.distance || 1} before moving to distance ${(stepData.distance || 1) + 1}!</p>
                        `;
                    } else {
                        explanation = `
                            <div class="ai-insight">
                                <div class="ai-insight-label">üéØ STEP ${stepData.step}</div>
                                <p>Explored vertex <strong>${stepData.vertex}</strong>. All its neighbors were already discovered, 
                                so we mark it <span style="color: #333;">BLACK</span> and continue with the next vertex in the queue.</p>
                            </div>
                            <p style="margin-top: 12px;"><strong>Remember:</strong> BFS uses FIFO (First In, First Out) - like a line at a store!</p>
                        `;
                    }
                    break;
                    
                case 'dfs':
                    explanation = `
                        <div class="ai-insight">
                            <div class="ai-insight-label">üéØ DFS STEP ${stepData.step}</div>
                            <p>DFS goes as deep as possible before backtracking. We're exploring vertex <strong>${stepData.vertex}</strong>. 
                            Think of it like exploring a maze - we go deep into one path before trying another!</p>
                        </div>
                        <p style="margin-top: 12px;"><strong>Key Concept:</strong> DFS uses a stack (or recursion) - LIFO (Last In, First Out).</p>
                    `;
                    break;
                    
                case 'dijkstra':
                    explanation = `
                        <div class="ai-insight">
                            <div class="ai-insight-label">üéØ DIJKSTRA STEP ${stepData.step}</div>
                            <p>We're finding the shortest paths using Dijkstra's greedy approach. 
                            Selected vertex <strong>${stepData.vertex}</strong> because it has the minimum distance estimate. 
                            Now we'll check if going through this vertex gives shorter paths to its neighbors!</p>
                        </div>
                        <p style="margin-top: 12px;"><strong>Greedy Choice:</strong> Always pick the closest unvisited vertex!</p>
                    `;
                    break;
                    
                case 'astar':
                    explanation = `
                        <div class="ai-insight">
                            <div class="ai-insight-label">üéØ A* STEP ${stepData.step}</div>
                            <p>A* uses f(n) = g(n) + h(n) to guide the search. We're choosing vertices that seem closest to the goal <strong>${goal ? goal.id : 'G'}</strong>. 
                            The heuristic function helps us explore promising paths first!</p>
                        </div>
                        <p style="margin-top: 12px;"><strong>Smart Search:</strong> Combining actual cost (g) with estimated cost (h) makes A* efficient!</p>
                    `;
                    break;
                    
                case 'prim':
                    explanation = `
                        <div class="ai-insight">
                            <div class="ai-insight-label">üéØ PRIM'S STEP ${stepData.step}</div>
                            <p>Building the Minimum Spanning Tree by always adding the cheapest edge that connects to our growing tree. 
                            We're selecting edges greedily to minimize total weight while connecting all vertices!</p>
                        </div>
                        <p style="margin-top: 12px;"><strong>MST Property:</strong> V-1 edges will connect V vertices with minimum total weight!</p>
                    `;
                    break;
                    
                case 'kruskal':
                    explanation = `
                        <div class="ai-insight">
                            <div class="ai-insight-label">üéØ KRUSKAL'S STEP ${stepData.step}</div>
                            <p>Processing edges in order of weight. Using Union-Find to detect if adding an edge would create a cycle. 
                            We skip edges that would form cycles and accept edges that safely connect different components!</p>
                        </div>
                        <p style="margin-top: 12px;"><strong>Edge-Based:</strong> Unlike Prim's, we consider all edges globally, sorted by weight!</p>
                    `;
                    break;
                    
                default:
                    explanation = `<p>Executing step ${stepData.step} of ${currentAlgorithm.toUpperCase()} algorithm...</p>`;
            }
            
            aiText.innerHTML = explanation;
        }

        // ============================================
        // INTERACTIVE APPLICATIONS
        // ============================================
        
        const applicationsData = {
            bfs: [
                {
                    id: 'social-network',
                    icon: 'üë•',
                    title: 'Social Network - Friend Suggestions',
                    description: 'Find friends within N degrees of separation, like LinkedIn or Facebook',
                    scenario: 'You want to find all friends who are 2 connections away from you'
                },
                {
                    id: 'web-crawler',
                    icon: 'üåê',
                    title: 'Web Crawler',
                    description: 'How search engines crawl websites level by level',
                    scenario: 'Crawl a website starting from homepage, exploring links level by level'
                },
                {
                    id: 'gps-navigation',
                    icon: 'üó∫Ô∏è',
                    title: 'GPS - Shortest Path',
                    description: 'Find shortest route in unweighted road networks',
                    scenario: 'Find the route with minimum number of intersections from home to school'
                }
            ],
            dfs: [
                {
                    id: 'maze-solver',
                    icon: 'üß©',
                    title: 'Maze Solver',
                    description: 'Find path through a maze by exploring deeply',
                    scenario: 'Navigate through a maze from entrance to exit'
                },
                {
                    id: 'cycle-detection',
                    icon: 'üîÑ',
                    title: 'Deadlock Detection',
                    description: 'Detect circular dependencies in systems',
                    scenario: 'Check if task dependencies form a circular loop (deadlock)'
                },
                {
                    id: 'topological-sort',
                    icon: 'üìã',
                    title: 'Task Scheduling',
                    description: 'Order tasks respecting dependencies (like build systems)',
                    scenario: 'Determine order to compile files based on dependencies'
                }
            ],
            dijkstra: [
                {
                    id: 'google-maps',
                    icon: 'üöó',
                    title: 'Google Maps - Shortest Route',
                    description: 'Find fastest route considering distance/time weights',
                    scenario: 'Find shortest driving route from your location to destination'
                },
                {
                    id: 'network-routing',
                    icon: 'üì°',
                    title: 'Network Packet Routing',
                    description: 'Route data packets through optimal network paths',
                    scenario: 'Send data packet through internet with minimum latency'
                },
                {
                    id: 'flight-routes',
                    icon: '‚úàÔ∏è',
                    title: 'Flight Route Planning',
                    description: 'Find cheapest flight route with layovers',
                    scenario: 'Find cheapest way to fly from New York to Tokyo'
                }
            ],
            astar: [
                {
                    id: 'game-pathfinding',
                    icon: 'üéÆ',
                    title: 'Video Game AI',
                    description: 'NPCs finding paths around obstacles efficiently',
                    scenario: 'Enemy character finding path to player in a game'
                },
                {
                    id: 'robot-navigation',
                    icon: 'ü§ñ',
                    title: 'Robot Navigation',
                    description: 'Autonomous robots navigating warehouses',
                    scenario: 'Warehouse robot finding optimal path to pick up package'
                },
                {
                    id: 'puzzle-solver',
                    icon: 'üß©',
                    title: '15-Puzzle Solver',
                    description: 'Solving sliding puzzles optimally',
                    scenario: 'Solve a scrambled 15-puzzle in minimum moves'
                }
            ],
            prim: [
                {
                    id: 'cable-network',
                    icon: 'üì°',
                    title: 'Cable Network Design',
                    description: 'Connect all houses with minimum cable length',
                    scenario: 'Design fiber optic network connecting all buildings in a city'
                },
                {
                    id: 'electrical-grid',
                    icon: '‚ö°',
                    title: 'Power Grid Layout',
                    description: 'Connect power stations with minimum wire cost',
                    scenario: 'Connect all neighborhoods to power grid minimizing wire costs'
                },
                {
                    id: 'cluster-analysis',
                    icon: 'üìä',
                    title: 'Data Clustering',
                    description: 'Group similar data points in machine learning',
                    scenario: 'Group customers by shopping behavior for targeted marketing'
                }
            ],
            kruskal: [
                {
                    id: 'road-network',
                    icon: 'üõ£Ô∏è',
                    title: 'Road Network Planning',
                    description: 'Build roads connecting cities with minimum cost',
                    scenario: 'Connect all cities in a region with minimum road construction cost'
                },
                {
                    id: 'circuit-design',
                    icon: 'üíª',
                    title: 'Circuit Board Design',
                    description: 'Connect components with minimum wire length',
                    scenario: 'Design circuit connections minimizing wire usage on PCB'
                },
                {
                    id: 'water-pipeline',
                    icon: 'üíß',
                    title: 'Water Pipeline Network',
                    description: 'Connect all areas with minimum pipeline',
                    scenario: 'Design water distribution network connecting all neighborhoods'
                }
            ]
        };

        let currentDemoApp = null;

        function loadApplications() {
            const contentArea = document.getElementById('contentArea');
            const apps = applicationsData[currentAlgorithm];
            
            let html = `
                <div class="tab-content active">
                    <h2>Real-World Applications - ${currentAlgorithm.toUpperCase()}</h2>
                    <p style="margin-bottom: 20px; color: #c0c0c0;">
                        Explore how ${currentAlgorithm.toUpperCase()} is used in real-world scenarios. Click on any application to try an interactive demo!
                    </p>
                    
                    <div class="applications-grid">
            `;
            
            apps.forEach((app, index) => {
                html += `
                    <div class="application-card" onclick="openDemo('${app.id}')">
                        <div class="app-icon">${app.icon}</div>
                        <div class="app-title">${app.title}</div>
                        <div class="app-description">${app.description}</div>
                        <button class="app-try-btn" onclick="event.stopPropagation(); openDemo('${app.id}')">
                            Try Interactive Demo ‚Üí
                        </button>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    
                    <div id="interactiveDemo" class="interactive-demo"></div>
                </div>
            `;
            
            contentArea.innerHTML = html;
        }

        function openDemo(appId) {
            currentDemoApp = appId;
            const app = applicationsData[currentAlgorithm].find(a => a.id === appId);
            const demoDiv = document.getElementById('interactiveDemo');
            
            if (!demoDiv || !app) return;
            
            let demoContent = generateDemoContent(app);
            
            demoDiv.innerHTML = `
                <div class="demo-header">
                    <div class="demo-title">${app.icon} ${app.title}</div>
                    <button class="demo-close" onclick="closeDemo()">Close Demo</button>
                </div>
                <div class="demo-content">
                    ${demoContent}
                </div>
            `;
            
            demoDiv.classList.add('active');
            demoDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function closeDemo() {
            const demoDiv = document.getElementById('interactiveDemo');
            if (demoDiv) {
                demoDiv.classList.remove('active');
            }
            currentDemoApp = null;
        }

        function generateDemoContent(app) {
            // Different demo content based on application type
            switch(app.id) {
                case 'social-network':
                    return `
                        <div class="demo-scenario">
                            <h4>Scenario: ${app.scenario}</h4>
                            <p>In social networks, BFS helps find people within N degrees of separation.</p>
                        </div>
                        
                        <div class="demo-input-group">
                            <label>Your Name:</label>
                            <input type="text" id="userName" placeholder="Enter your name" value="You">
                        </div>
                        
                        <div class="demo-input-group">
                            <label>Degrees of Separation:</label>
                            <select id="degrees">
                                <option value="1">1st Degree (Direct Friends)</option>
                                <option value="2" selected>2nd Degree (Friends of Friends)</option>
                                <option value="3">3rd Degree</option>
                            </select>
                        </div>
                        
                        <button onclick="runSocialNetworkDemo()" style="margin-top: 15px;">Find Friends</button>
                        
                        <div id="socialResult" style="display: none;" class="demo-result">
                            <h4>Results:</h4>
                            <div id="socialSteps"></div>
                        </div>
                    `;
                
                case 'google-maps':
                    return `
                        <div class="demo-scenario">
                            <h4>Scenario: ${app.scenario}</h4>
                            <p>Dijkstra's algorithm finds the shortest weighted path, perfect for navigation!</p>
                        </div>
                        
                        <div class="demo-input-group">
                            <label>Start Location:</label>
                            <select id="startLoc">
                                <option value="home">üè† Home</option>
                                <option value="work">üè¢ Work</option>
                                <option value="mall">üè¨ Mall</option>
                            </select>
                        </div>
                        
                        <div class="demo-input-group">
                            <label>Destination:</label>
                            <select id="endLoc">
                                <option value="work">üè¢ Work</option>
                                <option value="mall">üè¨ Mall</option>
                                <option value="airport">‚úàÔ∏è Airport</option>
                            </select>
                        </div>
                        
                        <button onclick="runMapsDemo()" style="margin-top: 15px;">Find Shortest Route</button>
                        
                        <div id="mapsResult" style="display: none;" class="demo-result">
                            <h4>Shortest Route Found:</h4>
                            <div id="mapsSteps"></div>
                        </div>
                    `;
                
                case 'game-pathfinding':
                    return `
                        <div class="demo-scenario">
                            <h4>Scenario: ${app.scenario}</h4>
                            <p>A* uses heuristics to find paths efficiently, crucial for game AI!</p>
                        </div>
                        
                        <div class="demo-visual" style="min-height: 300px;">
                            <div style="text-align: center; color: #888;">
                                <div style="font-size: 48px; margin-bottom: 20px;">üéÆ</div>
                                <p>Click "Start Pathfinding" to see enemy AI navigate to player</p>
                            </div>
                        </div>
                        
                        <button onclick="runGamePathfindingDemo()" style="margin-top: 15px;">Start Pathfinding</button>
                        
                        <div id="gameResult" style="display: none;" class="demo-result">
                            <h4>A* Pathfinding Steps:</h4>
                            <div id="gameSteps"></div>
                        </div>
                    `;
                
                case 'cable-network':
                    return `
                        <div class="demo-scenario">
                            <h4>Scenario: ${app.scenario}</h4>
                            <p>Prim's algorithm ensures all locations are connected with minimum total cable cost!</p>
                        </div>
                        
                        <div class="demo-input-group">
                            <label>Number of Buildings:</label>
                            <select id="numBuildings">
                                <option value="5">5 Buildings</option>
                                <option value="8" selected>8 Buildings</option>
                                <option value="10">10 Buildings</option>
                            </select>
                        </div>
                        
                        <button onclick="runCableNetworkDemo()" style="margin-top: 15px;">Design Network</button>
                        
                        <div id="cableResult" style="display: none;" class="demo-result">
                            <h4>Optimal Network Design:</h4>
                            <div id="cableSteps"></div>
                        </div>
                    `;
                
                default:
                    return `
                        <div class="demo-scenario">
                            <h4>Scenario: ${app.scenario}</h4>
                            <p>${app.description}</p>
                        </div>
                        
                        <div class="demo-visual">
                            <div style="text-align: center; color: #888;">
                                <div style="font-size: 64px; margin-bottom: 20px;">${app.icon}</div>
                                <p style="font-size: 16px; color: #1e88e5;">Interactive demo for this application</p>
                                <p style="margin-top: 10px;">Click the button below to see how ${currentAlgorithm.toUpperCase()} solves this problem!</p>
                            </div>
                        </div>
                        
                        <button onclick="runGenericDemo('${app.id}')" style="margin-top: 15px;">Run Demo</button>
                        
                        <div id="genericResult" style="display: none;" class="demo-result">
                            <h4>How ${currentAlgorithm.toUpperCase()} Solves This:</h4>
                            <div id="genericSteps"></div>
                        </div>
                    `;
            }
        }

        // Demo execution functions
        function runSocialNetworkDemo() {
            const userName = document.getElementById('userName').value || 'You';
            const degrees = document.getElementById('degrees').value;
            const resultDiv = document.getElementById('socialResult');
            const stepsDiv = document.getElementById('socialSteps');
            
            const friends = {
                1: ['Alice', 'Bob', 'Charlie'],
                2: ['David', 'Emma', 'Frank', 'Grace', 'Hannah'],
                3: ['Ivan', 'Julia', 'Kevin', 'Laura', 'Mike', 'Nancy']
            };
            
            let html = '<div class="demo-step">üîç Starting BFS from <span class="demo-highlight">' + userName + '</span></div>';
            
            for (let i = 1; i <= degrees; i++) {
                html += '<div class="demo-step">';
                html += `üìç Degree ${i}: Found ${friends[i].length} people - `;
                html += '<span class="demo-highlight">' + friends[i].join(', ') + '</span>';
                html += '</div>';
            }
            
            const total = friends[1].length + (degrees >= 2 ? friends[2].length : 0) + (degrees >= 3 ? friends[3].length : 0);
            html += '<div class="demo-step" style="background: #1e88e5; color: white; font-weight: 600;">';
            html += `‚úÖ Total friends within ${degrees} degree(s): ${total} people`;
            html += '</div>';
            
            stepsDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        function runMapsDemo() {
            const start = document.getElementById('startLoc').options[document.getElementById('startLoc').selectedIndex].text;
            const end = document.getElementById('endLoc').options[document.getElementById('endLoc').selectedIndex].text;
            const resultDiv = document.getElementById('mapsResult');
            const stepsDiv = document.getElementById('mapsSteps');
            
            const routes = {
                'home-work': { path: ['Home', 'Main St', 'Downtown', 'Work'], distance: 8.5, time: 15 },
                'home-mall': { path: ['Home', 'Park Ave', 'Mall'], distance: 5.2, time: 10 },
                'work-airport': { path: ['Work', 'Highway 101', 'Airport Exit', 'Airport'], distance: 25.3, time: 35 }
            };
            
            const key = start.toLowerCase().replace(/[^a-z]/g, '') + '-' + end.toLowerCase().replace(/[^a-z]/g, '');
            const route = routes[key] || { path: [start, 'Route A', 'Route B', end], distance: 12.0, time: 20 };
            
            let html = '<div class="demo-step">üöó Dijkstra finding shortest path from <span class="demo-highlight">' + start + '</span> to <span class="demo-highlight">' + end + '</span></div>';
            
            route.path.forEach((loc, i) => {
                html += '<div class="demo-step">';
                html += `${i + 1}. ${loc}`;
                if (i < route.path.length - 1) html += ' ‚Üí';
                html += '</div>';
            });
            
            html += '<div class="demo-step" style="background: #1e88e5; color: white; font-weight: 600;">';
            html += `‚úÖ Total Distance: ${route.distance} km | Estimated Time: ${route.time} minutes`;
            html += '</div>';
            
            stepsDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        function runGamePathfindingDemo() {
            const resultDiv = document.getElementById('gameResult');
            const stepsDiv = document.getElementById('gameSteps');
            
            let html = '<div class="demo-step">üéÆ Enemy AI using A* to find player...</div>';
            html += '<div class="demo-step">üìç Enemy position: (2, 8) | Player position: (15, 3)</div>';
            html += '<div class="demo-step">üß≠ Calculating f(n) = g(n) + h(n) for each step...</div>';
            html += '<div class="demo-step">‚úì Step 1: Move to (3, 7) - f=14</div>';
            html += '<div class="demo-step">‚úì Step 2: Move to (5, 6) - f=12</div>';
            html += '<div class="demo-step">‚úì Step 3: Move to (8, 5) - f=10</div>';
            html += '<div class="demo-step">‚úì Step 4: Move to (11, 4) - f=7</div>';
            html += '<div class="demo-step">‚úì Step 5: Move to (14, 3) - f=2</div>';
            html += '<div class="demo-step" style="background: #1e88e5; color: white; font-weight: 600;">üéØ Reached player! A* found optimal path avoiding obstacles in 5 steps</div>';
            
            stepsDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        function runCableNetworkDemo() {
            const numBuildings = document.getElementById('numBuildings').value;
            const resultDiv = document.getElementById('cableResult');
            const stepsDiv = document.getElementById('cableSteps');
            
            const costs = {
                5: { edges: 4, total: 245 },
                8: { edges: 7, total: 520 },
                10: { edges: 9, total: 780 }
            };
            
            const cost = costs[numBuildings];
            
            let html = '<div class="demo-step">üèóÔ∏è Designing cable network for ' + numBuildings + ' buildings using Prim\'s algorithm...</div>';
            html += '<div class="demo-step">üìä Starting from Building A...</div>';
            
            for (let i = 1; i <= cost.edges; i++) {
                const buildings = String.fromCharCode(65, 65 + i);
                const edgeCost = Math.floor(Math.random() * 100) + 30;
                html += `<div class="demo-step">‚úì Step ${i}: Connected Building ${buildings[0]} ‚Üî Building ${buildings[1]} (Cost: $${edgeCost}k)</div>`;
            }
            
            html += '<div class="demo-step" style="background: #1e88e5; color: white; font-weight: 600;">';
            html += `üéâ Network Complete! Total Cable Cost: $${cost.total}k | Total Edges: ${cost.edges}`;
            html += '</div>';
            html += '<div class="demo-step">üí° This is the minimum cost possible to connect all buildings!</div>';
            
            stepsDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        function runGenericDemo(appId) {
            const resultDiv = document.getElementById('genericResult');
            const stepsDiv = document.getElementById('genericSteps');
            
            let html = `<div class="demo-step">üöÄ Running ${currentAlgorithm.toUpperCase()} algorithm...</div>`;
            html += '<div class="demo-step">üìä Processing data and finding optimal solution...</div>';
            html += '<div class="demo-step">‚úì Step 1: Initialize data structures</div>';
            html += '<div class="demo-step">‚úì Step 2: Process elements systematically</div>';
            html += '<div class="demo-step">‚úì Step 3: Apply algorithm logic</div>';
            html += '<div class="demo-step">‚úì Step 4: Optimize and verify results</div>';
            html += '<div class="demo-step" style="background: #1e88e5; color: white; font-weight: 600;">‚úÖ Solution found! Algorithm completed successfully.</div>';
            
            stepsDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        }

        window.onload = function() {
            loadContent();
        };
    </script>
</body>
</html>
